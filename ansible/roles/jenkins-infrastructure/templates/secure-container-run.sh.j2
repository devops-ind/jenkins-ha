#!/bin/bash
# Jenkins Secure Container Execution Script
# Generated by Ansible - Security constraints applied

set -euo pipefail

# Configuration
CONTAINER_RUNTIME="{{ jenkins_container_runtime }}"
TEAM="${1:-}"
ENVIRONMENT="${2:-blue}"
ACTION="${3:-start}"

if [[ -z "$TEAM" ]]; then
    echo "Usage: $0 <team> <environment> <action>"
    echo "Example: $0 devops blue start"
    exit 1
fi

# Security constraints
SECURITY_OPTS=(
{% for opt in jenkins_container_security.security_opt %}
    --security-opt "{{ opt }}"
{% endfor %}
)

# Capability management
CAP_DROPS=(
{% for cap in jenkins_container_security.cap_drop %}
    --cap-drop {{ cap }}
{% endfor %}
)

CAP_ADDS=(
{% for cap in jenkins_container_security.cap_add %}
    --cap-add {{ cap }}
{% endfor %}
)

# Resource limits
MEMORY_LIMIT="{{ jenkins_container_security.memory_limit }}"
CPU_LIMIT="{{ jenkins_container_security.cpu_limit }}"

# User and group settings
RUN_USER="{{ jenkins_container_security.run_as_user }}"
RUN_GROUP="{{ jenkins_container_security.run_as_group }}"

# Read-only paths
READ_ONLY_PATHS=(
{% for path in jenkins_container_security.read_only_paths %}
    "{{ path }}"
{% endfor %}
)

# Tmpfs mounts
TMPFS_MOUNTS=(
{% for mount in jenkins_container_security.tmpfs %}
    "{{ mount }}"
{% endfor %}
)

# Environment whitelist
ENV_WHITELIST=(
{% for env in jenkins_container_security.env_whitelist %}
    "{{ env }}"
{% endfor %}
)

# Get team configuration
{% for team in jenkins_teams %}
if [[ "$TEAM" == "{{ team.name }}" ]]; then
    TEAM_PORT="{{ team.port }}"
    TEAM_AGENT_PORT="{{ team.agent_port }}"
    TEAM_MEMORY="{{ team.memory }}"
    TEAM_CPU_LIMIT="{{ team.cpu_limit }}"
fi
{% endfor %}

# Adjust ports for green environment
if [[ "$ENVIRONMENT" == "green" ]]; then
    TEAM_PORT=$((TEAM_PORT + 100))
    TEAM_AGENT_PORT=$((TEAM_AGENT_PORT + 100))
fi

CONTAINER_NAME="jenkins-${TEAM}-${ENVIRONMENT}"
IMAGE_NAME="{{ harbor_registry_url | default('harbor.company.com') }}/jenkins/jenkins-master:{{ jenkins_master_image_tag }}"

# Function to start container with security constraints
start_container() {
    echo "Starting secure Jenkins container: $CONTAINER_NAME"
    
    # Build container run command with security constraints
    local run_cmd="$CONTAINER_RUNTIME run -d"
    
    # Basic container settings
    run_cmd+=" --name $CONTAINER_NAME"
    run_cmd+=" --hostname $CONTAINER_NAME"
    
    # User and security settings
    run_cmd+=" --user $RUN_USER:$RUN_GROUP"
{% if jenkins_container_security.no_new_privileges %}
    run_cmd+=" --privileged=false"
{% endif %}
{% if jenkins_container_security.read_only_root_filesystem %}
    run_cmd+=" --read-only"
{% endif %}
    
    # Add security options
    for opt in "${SECURITY_OPTS[@]}"; do
        run_cmd+=" $opt"
    done
    
    # Add capability drops
    for cap in "${CAP_DROPS[@]}"; do
        run_cmd+=" $cap"
    done
    
    # Add capability adds
    for cap in "${CAP_ADDS[@]}"; do
        run_cmd+=" $cap"
    done
    
    # Resource limits
    run_cmd+=" --memory $MEMORY_LIMIT"
    run_cmd+=" --cpus $CPU_LIMIT"
    
    # Network settings (bridge mode for security)
    run_cmd+=" --network bridge"
    
    # Port mappings
    run_cmd+=" -p $TEAM_PORT:8080"
    run_cmd+=" -p $TEAM_AGENT_PORT:50000"
    
    # Environment variables (whitelist only)
    run_cmd+=" -e JAVA_OPTS='{{ jenkins_master_java_opts }}'"
    run_cmd+=" -e JENKINS_OPTS='--httpPort=8080 --prefix={{ jenkins_context_path }}'"
    run_cmd+=" -e TZ='{{ common_timezone | default('UTC') }}'"
    run_cmd+=" -e JENKINS_TEAM=$TEAM"
    run_cmd+=" -e JENKINS_ENVIRONMENT=$ENVIRONMENT"
    
    # Volume mounts with security constraints
    run_cmd+=" -v {{ jenkins_home_dir }}/teams/${TEAM}/${ENVIRONMENT}:/var/jenkins_home:rw,Z"
    run_cmd+=" -v {{ jenkins_shared_workspace }}:/shared/workspace:rw,Z"
    
{% if jenkins_container_runtime == 'docker' %}
    # Docker socket (with restrictions)
    run_cmd+=" -v /var/run/docker.sock:/var/run/docker.sock:rw"
{% endif %}
    
    # Tmpfs mounts for security
    for tmpfs in "${TMPFS_MOUNTS[@]}"; do
        local target=$(echo "$tmpfs" | cut -d: -f1)
        local options=$(echo "$tmpfs" | cut -d: -f2-)
        run_cmd+=" --tmpfs $target:$options"
    done
    
    # Read-only system paths
    for ro_path in "${READ_ONLY_PATHS[@]}"; do
        run_cmd+=" -v $ro_path:$ro_path:ro"
    done
    
    # Health check
    run_cmd+=" --health-cmd='curl -f http://localhost:8080/login || exit 1'"
    run_cmd+=" --health-interval=30s"
    run_cmd+=" --health-timeout=10s"
    run_cmd+=" --health-retries=3"
    run_cmd+=" --health-start-period=60s"
    
    # Restart policy
    run_cmd+=" --restart unless-stopped"
    
    # Logging configuration
    run_cmd+=" --log-driver {{ jenkins_log_driver }}"
    run_cmd+=" --log-opt max-size={{ jenkins_log_max_size }}"
    run_cmd+=" --log-opt max-file={{ jenkins_log_max_files }}"
    run_cmd+=" --log-opt tag=$CONTAINER_NAME"
    
    # Labels for monitoring
    run_cmd+=" --label com.company.service=jenkins"
    run_cmd+=" --label com.company.team=$TEAM"
    run_cmd+=" --label com.company.environment=$ENVIRONMENT"
    run_cmd+=" --label com.company.security.profile=restricted"
    run_cmd+=" --label com.company.monitoring.enabled=true"
    
    # Image
    run_cmd+=" $IMAGE_NAME"
    
    # Execute the command
    echo "Executing: $run_cmd"
    eval $run_cmd
    
    # Wait for container to be healthy
    echo "Waiting for container to become healthy..."
    local retries=0
    local max_retries=30
    
    while [[ $retries -lt $max_retries ]]; do
        if $CONTAINER_RUNTIME inspect --format='{{.State.Health.Status}}' "$CONTAINER_NAME" 2>/dev/null | grep -q "healthy"; then
            echo "✅ Container $CONTAINER_NAME is healthy"
            return 0
        fi
        
        echo "Waiting for health check... ($((retries + 1))/$max_retries)"
        sleep 10
        ((retries++))
    done
    
    echo "⚠️ Container health check timeout"
    return 1
}

# Function to stop container
stop_container() {
    echo "Stopping container: $CONTAINER_NAME"
    
    if $CONTAINER_RUNTIME ps -q -f name="$CONTAINER_NAME" | grep -q .; then
        $CONTAINER_RUNTIME stop "$CONTAINER_NAME"
        echo "✅ Container $CONTAINER_NAME stopped"
    else
        echo "Container $CONTAINER_NAME not running"
    fi
}

# Function to remove container
remove_container() {
    echo "Removing container: $CONTAINER_NAME"
    
    if $CONTAINER_RUNTIME ps -aq -f name="$CONTAINER_NAME" | grep -q .; then
        $CONTAINER_RUNTIME rm -f "$CONTAINER_NAME"
        echo "✅ Container $CONTAINER_NAME removed"
    else
        echo "Container $CONTAINER_NAME does not exist"
    fi
}

# Function to restart container
restart_container() {
    echo "Restarting container: $CONTAINER_NAME"
    stop_container
    sleep 5
    remove_container
    start_container
}

# Function to show container status
status_container() {
    echo "Status for container: $CONTAINER_NAME"
    
    if $CONTAINER_RUNTIME ps -q -f name="$CONTAINER_NAME" | grep -q .; then
        echo "✅ Container is running"
        $CONTAINER_RUNTIME ps -f name="$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        # Show health status
        local health=$($CONTAINER_RUNTIME inspect --format='{{.State.Health.Status}}' "$CONTAINER_NAME" 2>/dev/null || echo "unknown")
        echo "Health Status: $health"
        
        # Show resource usage
        echo "Resource Usage:"
        $CONTAINER_RUNTIME stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}" "$CONTAINER_NAME"
    else
        echo "❌ Container is not running"
    fi
}

# Main execution
case "$ACTION" in
    "start")
        start_container
        ;;
    "stop")
        stop_container
        ;;
    "restart")
        restart_container
        ;;
    "remove")
        remove_container
        ;;
    "status")
        status_container
        ;;
    *)
        echo "Invalid action: $ACTION"
        echo "Valid actions: start, stop, restart, remove, status"
        exit 1
        ;;
esac