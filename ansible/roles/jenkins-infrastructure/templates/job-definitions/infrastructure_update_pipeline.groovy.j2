<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@2.47">
  <actions/>
  <description>Infrastructure Pipeline: Self-Updating Jenkins Infrastructure

This pipeline manages infrastructure updates including:
- Updating Jenkins images to latest versions
- Applying configuration changes via Ansible
- Rolling restart of services with health checks
- Rollback capabilities if issues detected

This pipeline enables Jenkins to manage its own infrastructure updates automatically.
</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <jenkins.model.BuildDiscarderProperty>
      <strategy class="hudson.tasks.LogRotator">
        <daysToKeep>60</daysToKeep>
        <numToKeep>30</numToKeep>
        <artifactDaysToKeep>-1</artifactDaysToKeep>
        <artifactNumToKeep>-1</artifactNumToKeep>
      </strategy>
    </jenkins.model.BuildDiscarderProperty>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <n>IMAGE_TAG</n>
          <description>Jenkins image tag to deploy (leave empty for latest)</description>
          <defaultValue>latest</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.BooleanParameterDefinition>
          <n>RESTART_SERVICES</n>
          <description>Restart Jenkins services after update</description>
          <defaultValue>true</defaultValue>
        </hudson.model.BooleanParameterDefinition>
        <hudson.model.BooleanParameterDefinition>
          <n>UPDATE_CONFIGURATION</n>
          <description>Update Jenkins configuration (JCasC, systemd services)</description>
          <defaultValue>true</defaultValue>
        </hudson.model.BooleanParameterDefinition>
        <hudson.model.BooleanParameterDefinition>
          <n>UPDATE_MONITORING</n>
          <description>Update monitoring configuration</description>
          <defaultValue>false</defaultValue>
        </hudson.model.BooleanParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <n>UPDATE_SCOPE</n>
          <description>Scope of infrastructure update</description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>current-master</string>
              <string>all-masters</string>
              <string>agents-only</string>
              <string>monitoring-only</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <n>UPDATE_REASON</n>
          <description>Reason for infrastructure update</description>
          <defaultValue>Scheduled maintenance</defaultValue>
          <trim>true</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.BooleanParameterDefinition>
          <n>ENABLE_ROLLBACK</n>
          <description>Enable automatic rollback on failure</description>
          <defaultValue>true</defaultValue>
        </hudson.model.BooleanParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2.94">
    <script>#!/usr/bin/env groovy

pipeline {
    agent {
        label 'dind docker-manager static privileged'
    }
    
    options {
        buildDiscarder(logRotator(daysToKeepStr: '60', numToKeepStr: '30'))
        timeout(time: 3, unit: 'HOURS')
        timestamps()
        ansiColor('xterm')
        skipDefaultCheckout()
    }
    
    environment {
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_STDOUT_CALLBACK = 'yaml'
        HARBOR_REGISTRY = '{{ harbor_registry_url }}'
        HARBOR_PROJECT = '{{ harbor_project }}'
        JENKINS_HOME_DIR = '{{ jenkins_home_dir }}'
        DEPLOYMENT_ENV = '{{ deployment_environment | default("production") }}'
        TIMESTAMP = sh(script: 'date +%Y%m%d_%H%M%S', returnStdout: true).trim()
        HOSTNAME = sh(script: 'hostname', returnStdout: true).trim()
        CURRENT_IMAGE_TAG = sh(script: 'docker inspect jenkins-master-$(hostname) --format="{{.Config.Image}}" | cut -d: -f2 || echo "unknown"', returnStdout: true).trim()
    }
    
    stages {
        stage('Pre-Update Validation') {
            steps {
                script {
                    echo "ðŸ”„ Jenkins Infrastructure Update Pipeline"
                    echo "ðŸ·ï¸ Target Image Tag: ${params.IMAGE_TAG}"
                    echo "ðŸ·ï¸ Current Image Tag: ${CURRENT_IMAGE_TAG}"
                    echo "ðŸŽ¯ Update Scope: ${params.UPDATE_SCOPE}"
                    echo "ðŸ“ Update Reason: ${params.UPDATE_REASON}"
                    echo "â° Timestamp: ${TIMESTAMP}"
                    echo "ðŸ–¥ï¸ Hostname: ${HOSTNAME}"
                    
                    // Validate current system state
                    sh """
                        echo "ðŸ” Validating current system state..."
                        
                        # Check if Jenkins is running
                        if ! systemctl is-active --quiet jenkins-master; then
                            echo "âŒ Jenkins master is not running on this host"
                            exit 1
                        fi
                        
                        # Check Docker daemon
                        if ! systemctl is-active --quiet docker; then
                            echo "âŒ Docker service is not running"
                            exit 1
                        fi
                        
                        # Check available disk space
                        AVAILABLE_GB=\$(df /var/lib/docker | tail -1 | awk '{print \$4}' | sed 's/[^0-9]*//g')
                        AVAILABLE_GB=\$((AVAILABLE_GB / 1024 / 1024))
                        
                        if [ "\$AVAILABLE_GB" -lt "5" ]; then
                            echo "âš ï¸ Warning: Low disk space (\${AVAILABLE_GB}GB available)"
                        fi
                        
                        echo "âœ… System validation passed"
                    """
                }
            }
        }
        
        stage('Checkout Infrastructure Repository') {
            steps {
                script {
                    echo "ðŸ“¥ Checking out infrastructure repository..."
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: '*/main']],
                        userRemoteConfigs: [[
                            url: '{{ jenkins_infrastructure_repo_url }}',
                            credentialsId: '{{ git_credentials_id }}'
                        ]]
                    ])
                    
                    // Validate Ansible configuration
                    sh """
                        cd ansible
                        ansible-playbook site.yml --syntax-check
                        ansible-inventory --list > /dev/null
                        echo "âœ… Ansible configuration validated"
                    """
                }
            }
        }
        
        stage('Create Pre-Update Backup') {
            when {
                expression { params.RESTART_SERVICES }
            }
            steps {
                script {
                    echo "ðŸ’¾ Creating pre-update backup..."
                    
                    // Trigger backup job and wait for completion
                    def backupBuild = build job: 'Infrastructure/Infrastructure-Backup',
                                           parameters: [
                                               string(name: 'BACKUP_TYPE', value: 'configuration-only'),
                                               string(name: 'CUSTOM_TAG', value: "pre-update-${TIMESTAMP}"),
                                               booleanParam(name: 'VERIFY_BACKUP', value: true),
                                               booleanParam(name: 'SEND_NOTIFICATIONS', value: false)
                                           ],
                                           wait: true
                    
                    if (backupBuild.result != 'SUCCESS') {
                        error("âŒ Pre-update backup failed!")
                    }
                    
                    echo "âœ… Pre-update backup completed successfully"
                }
            }
        }
        
        stage('Update Infrastructure with Ansible') {
            steps {
                script {
                    echo "ðŸ—ï¸ Updating infrastructure using Ansible roles..."
                    
                    // Create inventory for the target hosts
                    def inventoryContent = ""
                    
                    if (params.UPDATE_SCOPE == 'all-masters') {
                        inventoryContent = """
[jenkins_masters]
{% for host in groups['jenkins_masters'] %}
{{ host }} ansible_host={{ hostvars[host]['ansible_host'] }}
{% endfor %}

[jenkins_agents]
{% for host in groups['jenkins_agents'] %}
{{ host }} ansible_host={{ hostvars[host]['ansible_host'] }}
{% endfor %}

[monitoring]
{% for host in groups['monitoring'] %}
{{ host }} ansible_host={{ hostvars[host]['ansible_host'] }}
{% endfor %}
"""
                    } else {
                        inventoryContent = """
[jenkins_masters]
${HOSTNAME} ansible_connection=local ansible_python_interpreter={{ ansible_playbook_python }}

[jenkins_agents]
${HOSTNAME} ansible_connection=local

[monitoring]
${HOSTNAME} ansible_connection=local
"""
                    }
                    
                    writeFile file: 'update_inventory', text: inventoryContent
                    
                    // Create comprehensive update playbook
                    def playbookContent = """
---
- name: Update Jenkins Infrastructure
  hosts: jenkins_masters
  become: yes
  gather_facts: yes
  serial: "${params.UPDATE_SCOPE == 'all-masters' ? '1' : '100%'}"
  vars:
    jenkins_master_image_tag: "${params.IMAGE_TAG}"
    jenkins_agent_image_tag: "${params.IMAGE_TAG}"
    jenkins_force_pull_images: true
    jenkins_restart_services: ${params.RESTART_SERVICES}
    update_configuration: ${params.UPDATE_CONFIGURATION}
    update_monitoring: ${params.UPDATE_MONITORING}
    deployment_environment: "${DEPLOYMENT_ENV}"
    rolling_update: true
  pre_tasks:
    - name: Create pre-update system snapshot
      command: systemctl snapshot pre-update-{{ ansible_date_time.epoch }}
      ignore_errors: yes
      
    - name: Stop Jenkins gracefully before update
      systemd:
        name: jenkins-master
        state: stopped
      when: jenkins_restart_services | bool
      
  roles:
    - role: jenkins-infrastructure
      when: update_configuration | bool or jenkins_restart_services | bool
      vars:
        jenkins_update_mode: true
        jenkins_preserve_data: true
        
    - role: harbor
      when: jenkins_force_pull_images | bool
      vars:
        harbor_pull_images: true
        
  post_tasks:
    - name: Start Jenkins service
      systemd:
        name: jenkins-master
        state: started
        enabled: yes
      when: jenkins_restart_services | bool
      
    - name: Wait for Jenkins to be ready
      uri:
        url: "http://localhost:{{ jenkins_master_port }}/login"
        method: GET
        status_code: 200
      register: jenkins_ready
      until: jenkins_ready.status == 200
      retries: 30
      delay: 10
      when: jenkins_restart_services | bool
      
    - name: Validate Jenkins API
      uri:
        url: "http://localhost:{{ jenkins_master_port }}/api/json"
        method: GET
        user: "{{ jenkins_admin_user }}"
        password: "{{ jenkins_admin_password }}"
        status_code: 200
      when: jenkins_restart_services | bool

- name: Update Monitoring Stack
  hosts: monitoring
  become: yes
  gather_facts: yes
  when: update_monitoring | bool
  roles:
    - role: monitoring
      vars:
        monitoring_update_mode: true
        prometheus_reload_config: true
        grafana_restart_service: true

- name: Update Agent Infrastructure
  hosts: jenkins_agents
  become: yes
  gather_facts: yes
  when: "'agents' in '${params.UPDATE_SCOPE}' or '${params.UPDATE_SCOPE}' == 'all-masters'"
  roles:
    - role: jenkins-infrastructure
      vars:
        jenkins_agent_only: true
        jenkins_agent_image_tag: "${params.IMAGE_TAG}"
        jenkins_restart_agents: ${params.RESTART_SERVICES}
"""
                    
                    writeFile file: 'update-infrastructure.yml', text: playbookContent
                    
                    // Execute ansible playbook
                    sh """
                        echo "ðŸš€ Executing Ansible infrastructure update..."
                        
                        # Set vault password if exists
                        export ANSIBLE_VAULT_PASSWORD_FILE=\${PWD}/environments/vault-passwords/production.txt
                        
                        ansible-playbook -i update_inventory \
                            update-infrastructure.yml \
                            --extra-vars "target_image_tag=${params.IMAGE_TAG}" \
                            --extra-vars "update_reason='${params.UPDATE_REASON}'" \
                            --extra-vars "enable_rollback=${params.ENABLE_ROLLBACK}" \
                            --extra-vars "deployment_timestamp=${TIMESTAMP}" \
                            -v
                    """
                }
            }
        }
        
        stage('Post-Update Health Validation') {
            steps {
                script {
                    echo "ðŸ¥ Performing final health validation..."
                    
                    // Trigger comprehensive health check job
                    def healthBuild = build job: 'Infrastructure/Infrastructure-Health-Check',
                                           parameters: [
                                               booleanParam(name: 'DEEP_HEALTH_CHECK', value: true),
                                               booleanParam(name: 'CHECK_AGENTS', value: true),
                                               booleanParam(name: 'CHECK_MONITORING', value: params.UPDATE_MONITORING),
                                               string(name: 'UPDATE_CONTEXT', value: "post-update-${TIMESTAMP}")
                                           ],
                                           wait: true
                    
                    if (healthBuild.result == 'SUCCESS') {
                        echo "âœ… All health checks passed successfully"
                    } else {
                        echo "âš ï¸ Health check completed with warnings - check logs for details"
                    }
                }
            }
        }
        
        stage('Post-Update Validation') {
            steps {
                script {
                    echo "âœ… Performing post-update validation..."
                    
                    // Trigger health check pipeline
                    def healthBuild = build job: 'Infrastructure/Infrastructure-Health-Check',
                                           parameters: [
                                               booleanParam(name: 'DEEP_HEALTH_CHECK', value: true),
                                               booleanParam(name: 'CHECK_AGENTS', value: true),
                                               booleanParam(name: 'CHECK_MONITORING', value: params.UPDATE_MONITORING)
                                           ],
                                           wait: true
                    
                    if (healthBuild.result != 'SUCCESS') {
                        if (params.ENABLE_ROLLBACK) {
                            echo "âŒ Health check failed! Initiating rollback..."
                            error("Health check failed after update")
                        } else {
                            echo "âš ï¸ Health check failed but rollback is disabled"
                        }
                    }
                    
                    echo "âœ… Post-update validation completed"
                }
            }
        }
        
        stage('Update Documentation') {
            steps {
                script {
                    echo "ðŸ“ Updating infrastructure documentation..."
                    
                    sh """
                        # Create update record
                        cat > infrastructure-update-${TIMESTAMP}.md << EOF
# Infrastructure Update Record

**Date**: $(date)
**Build**: ${env.BUILD_NUMBER}
**Triggered By**: ${env.BUILD_USER_ID ?: 'system'}

## Update Details
- **Image Tag**: ${params.IMAGE_TAG}
- **Previous Tag**: ${CURRENT_IMAGE_TAG}
- **Update Scope**: ${params.UPDATE_SCOPE}
- **Reason**: ${params.UPDATE_REASON}

## Changes Applied
- Restart Services: ${params.RESTART_SERVICES}
- Update Configuration: ${params.UPDATE_CONFIGURATION}
- Update Monitoring: ${params.UPDATE_MONITORING}

## Validation Results
- Jenkins Health: âœ… Passed
- API Connectivity: âœ… Passed
- Agent Connectivity: âœ… Verified

## Rollback Information
- Rollback Enabled: ${params.ENABLE_ROLLBACK}
- Pre-Update Backup: pre-update-${TIMESTAMP}

EOF
                        
                        echo "âœ… Documentation updated"
                    """
                    
                    // Archive update documentation
                    archiveArtifacts artifacts: "infrastructure-update-${TIMESTAMP}.md", fingerprint: true
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Clean up workspace
                cleanWs()
            }
        }
        
        success {
            script {
                echo "âœ… Infrastructure Update Completed Successfully!"
                
                def updateSummary = """
                    âœ… Jenkins Infrastructure Update Successful
                    
                    ðŸ·ï¸ Image: ${params.IMAGE_TAG} (was: ${CURRENT_IMAGE_TAG})
                    ðŸŽ¯ Scope: ${params.UPDATE_SCOPE}
                    ðŸ“ Reason: ${params.UPDATE_REASON}
                    â±ï¸ Duration: ${currentBuild.durationString}
                    ðŸ–¥ï¸ Host: ${HOSTNAME}
                    
                    ðŸ”— Build: ${env.BUILD_URL}
                """.stripIndent()
                
                if (env.SLACK_WEBHOOK) {
                    slackSend(
                        channel: '#infrastructure',
                        color: 'good',
                        message: updateSummary
                    )
                }
                
                echo updateSummary
            }
        }
        
        failure {
            script {
                echo "âŒ Infrastructure Update Failed!"
                
                if (params.ENABLE_ROLLBACK && params.RESTART_SERVICES) {
                    echo "ðŸ”„ Initiating automatic rollback..."
                    
                    try {
                        // Rollback to previous image
                        sh """
                            echo "ðŸ”„ Rolling back to previous image: ${CURRENT_IMAGE_TAG}"
                            
                            # Stop current service
                            sudo systemctl stop jenkins-master
                            
                            # Remove current container
                            docker stop jenkins-master-${HOSTNAME} || true
                            docker rm jenkins-master-${HOSTNAME} || true
                            
                            # Start with previous image
                            docker run -d --name jenkins-master-${HOSTNAME} \
                                --restart unless-stopped \
                                --network jenkins-network \
                                -p {{ jenkins_master_port }}:8080 \
                                -p {{ jenkins_agent_port }}:50000 \
                                -v jenkins_data:/var/jenkins_home \
                                \${HARBOR_REGISTRY}/\${HARBOR_PROJECT}/jenkins-master:${CURRENT_IMAGE_TAG}
                            
                            # Start systemd service
                            sudo systemctl start jenkins-master
                            
                            echo "âœ… Rollback completed"
                        """
                        
                        echo "âœ… Rollback completed successfully"
                    } catch (Exception e) {
                        echo "âŒ Rollback failed: ${e.getMessage()}"
                    }
                }
                
                def failureMessage = """
                    âŒ Jenkins Infrastructure Update Failed
                    
                    ðŸ·ï¸ Target Image: ${params.IMAGE_TAG}
                    ðŸŽ¯ Scope: ${params.UPDATE_SCOPE}
                    â±ï¸ Duration: ${currentBuild.durationString}
                    ðŸ”„ Rollback: ${params.ENABLE_ROLLBACK ? 'Attempted' : 'Disabled'}
                    
                    ðŸ”— Build: ${env.BUILD_URL}
                    ðŸ“‹ Please check logs for details
                """.stripIndent()
                
                if (env.SLACK_WEBHOOK) {
                    slackSend(
                        channel: '#infrastructure',
                        color: 'danger',
                        message: failureMessage
                    )
                }
            }
        }
    }
}
    </script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>