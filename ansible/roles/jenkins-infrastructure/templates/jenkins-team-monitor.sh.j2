#!/bin/bash
# Jenkins Multi-Team Monitoring Script
# Generated by Ansible for {{ ansible_hostname }}

set -euo pipefail

# Configuration
JENKINS_HOME="{{ jenkins_home_dir }}"
CONTAINER_RUNTIME="{{ jenkins_container_runtime }}"
LOG_FILE="${JENKINS_HOME}/logs/team-monitor.log"
METRICS_FILE="${JENKINS_HOME}/logs/team-metrics.json"

# Ensure log directory exists
mkdir -p "${JENKINS_HOME}/logs"

# Logging function
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" | tee -a "${LOG_FILE}"
}

# Get container statistics
get_container_stats() {
    local container_name="$1"
    local team="$2"
    local environment="$3"
    
    if [ "${CONTAINER_RUNTIME}" = "docker" ]; then
        if docker ps --format "table {{ '{{.Names}}' }}" | grep -q "${container_name}"; then
            local stats_raw
            stats_raw=$(docker stats --no-stream --format "{{ '{{.CPUPerc}}' }},{{ '{{.MemUsage}}' }},{{ '{{.MemPerc}}' }},{{ '{{.NetIO}}' }},{{ '{{.BlockIO}}' }}" "${container_name}" 2>/dev/null || echo "0.00%,0B / 0B,0.00%,0B / 0B,0B / 0B")
            
            IFS=',' read -r cpu memory mem_perc netio blockio <<< "${stats_raw}"
            
            echo "{
                \"container\": \"${container_name}\",
                \"team\": \"${team}\",
                \"environment\": \"${environment}\",
                \"status\": \"running\",
                \"cpu_percent\": \"${cpu}\",
                \"memory_usage\": \"${memory}\",
                \"memory_percent\": \"${mem_perc}\",
                \"network_io\": \"${netio}\",
                \"block_io\": \"${blockio}\",
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
            }"
        else
            echo "{
                \"container\": \"${container_name}\",
                \"team\": \"${team}\",
                \"environment\": \"${environment}\",
                \"status\": \"stopped\",
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
            }"
        fi
    else
        if podman ps --format "table {{ '{{.Names}}' }}" | grep -q "${container_name}"; then
            local stats_raw
            stats_raw=$(podman stats --no-stream --format "{{ '{{.CPUPerc}}' }},{{ '{{.MemUsage}}' }},{{ '{{.MemPerc}}' }}" "${container_name}" 2>/dev/null || echo "0.00%,0B / 0B,0.00%")
            
            IFS=',' read -r cpu memory mem_perc <<< "${stats_raw}"
            
            echo "{
                \"container\": \"${container_name}\",
                \"team\": \"${team}\",
                \"environment\": \"${environment}\",
                \"status\": \"running\",
                \"cpu_percent\": \"${cpu}\",
                \"memory_usage\": \"${memory}\",
                \"memory_percent\": \"${mem_perc}\",
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
            }"
        else
            echo "{
                \"container\": \"${container_name}\",
                \"team\": \"${team}\",
                \"environment\": \"${environment}\",
                \"status\": \"stopped\",
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
            }"
        fi
    fi
}

# Get Jenkins application metrics
get_jenkins_metrics() {
    local team="$1"
    local port="$2"
    local environment="$3"
    
    local jenkins_url="http://localhost:${port}"
    local metrics="{}"
    
    # Try to get basic Jenkins metrics
    if curl -f -s "${jenkins_url}/api/json" > /dev/null 2>&1; then
        local queue_size
        local executor_total
        local executor_busy
        
        # Get queue size
        queue_size=$(curl -f -s "${jenkins_url}/queue/api/json" | jq -r '.items | length' 2>/dev/null || echo "0")
        
        # Get executor information
        local computer_info
        computer_info=$(curl -f -s "${jenkins_url}/computer/api/json" 2>/dev/null || echo '{"computer":[]}')
        executor_total=$(echo "${computer_info}" | jq -r '[.computer[].numExecutors] | add' 2>/dev/null || echo "0")
        executor_busy=$(echo "${computer_info}" | jq -r '[.computer[].executors[].currentExecutable] | map(select(. != null)) | length' 2>/dev/null || echo "0")
        
        metrics=$(cat <<EOF
{
    "team": "${team}",
    "environment": "${environment}",
    "port": ${port},
    "status": "healthy",
    "queue_size": ${queue_size},
    "executors_total": ${executor_total},
    "executors_busy": ${executor_busy},
    "executors_free": $((executor_total - executor_busy)),
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
        )
    else
        metrics=$(cat <<EOF
{
    "team": "${team}",
    "environment": "${environment}",
    "port": ${port},
    "status": "unhealthy",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
        )
    fi
    
    echo "${metrics}"
}

# Monitor specific team
monitor_team() {
    local team="$1"
    
    log "=== Monitoring team: ${team} ==="
    
    {% for team in jenkins_teams %}
    if [ "${team}" = "{{ team.name }}" ]; then
        local blue_container="jenkins-{{ team.name }}-blue"
        local green_container="jenkins-{{ team.name }}-green"
        local team_port="{{ team.port }}"
        local active_env="{{ team.active_environment }}"
        
        # Get container stats
        local blue_stats
        local green_stats
        blue_stats=$(get_container_stats "${blue_container}" "{{ team.name }}" "blue")
        green_stats=$(get_container_stats "${green_container}" "{{ team.name }}" "green")
        
        # Get Jenkins application metrics for active environment
        local jenkins_metrics
        jenkins_metrics=$(get_jenkins_metrics "{{ team.name }}" "${team_port}" "${active_env}")
        
        # Display results
        log "Blue Environment Stats:"
        echo "${blue_stats}" | jq '.'
        
        log "Green Environment Stats:"
        echo "${green_stats}" | jq '.'
        
        log "Jenkins Application Metrics:"
        echo "${jenkins_metrics}" | jq '.'
        
        # Save to metrics file
        {
            echo "{"
            echo "  \"team\": \"{{ team.name }}\","
            echo "  \"active_environment\": \"${active_env}\","
            echo "  \"blue_container\": ${blue_stats},"
            echo "  \"green_container\": ${green_stats},"
            echo "  \"jenkins_metrics\": ${jenkins_metrics}"
            echo "}"
        } > "${METRICS_FILE}.{{ team.name }}"
        
        return 0
    fi
    {% endfor %}
    
    log "ERROR: Unknown team '${team}'"
    return 1
}

# Monitor all teams
monitor_all_teams() {
    log "=== Monitoring All Jenkins Teams ==="
    
    local all_metrics="["
    local first_team=true
    
    {% for team in jenkins_teams %}
    log "Monitoring team: {{ team.name }}"
    
    local blue_container="jenkins-{{ team.name }}-blue"
    local green_container="jenkins-{{ team.name }}-green"
    local team_port="{{ team.port }}"
    local active_env="{{ team.active_environment }}"
    
    # Get container stats
    local blue_stats
    local green_stats
    blue_stats=$(get_container_stats "${blue_container}" "{{ team.name }}" "blue")
    green_stats=$(get_container_stats "${green_container}" "{{ team.name }}" "green")
    
    # Get Jenkins application metrics for active environment
    local jenkins_metrics
    jenkins_metrics=$(get_jenkins_metrics "{{ team.name }}" "${team_port}" "${active_env}")
    
    # Add to overall metrics
    if [ "${first_team}" = "false" ]; then
        all_metrics+=","
    fi
    first_team=false
    
    all_metrics+=$(cat <<EOF
{
    "team": "{{ team.name }}",
    "active_environment": "${active_env}",
    "blue_container": ${blue_stats},
    "green_container": ${green_stats},
    "jenkins_metrics": ${jenkins_metrics}
}
EOF
    )
    
    # Display team summary
    log "{{ team.name | upper }} Summary:"
    log "  Active Environment: ${active_env}"
    log "  Blue Container: $(echo "${blue_stats}" | jq -r '.status')"
    log "  Green Container: $(echo "${green_stats}" | jq -r '.status')"
    log "  Jenkins Status: $(echo "${jenkins_metrics}" | jq -r '.status')"
    {% endfor %}
    
    all_metrics+="]"
    
    # Save consolidated metrics
    echo "${all_metrics}" | jq '.' > "${METRICS_FILE}"
    
    log "=== Monitoring Complete ==="
    log "Metrics saved to: ${METRICS_FILE}"
}

# Generate summary report
generate_summary() {
    if [ -f "${METRICS_FILE}" ]; then
        log "=== Jenkins Multi-Team Summary Report ==="
        
        local total_teams
        local healthy_teams
        local total_containers
        local running_containers
        
        total_teams=$(jq '. | length' "${METRICS_FILE}")
        healthy_teams=$(jq '[.[] | select(.jenkins_metrics.status == "healthy")] | length' "${METRICS_FILE}")
        total_containers=$(jq '[.[].blue_container, .[].green_container] | length' "${METRICS_FILE}")
        running_containers=$(jq '[.[].blue_container, .[].green_container] | map(select(.status == "running")) | length' "${METRICS_FILE}")
        
        log "Teams: ${healthy_teams}/${total_teams} healthy"
        log "Containers: ${running_containers}/${total_containers} running"
        
        # Per-team summary
        jq -r '.[] | "Team: \(.team) | Active: \(.active_environment) | Status: \(.jenkins_metrics.status) | Queue: \(.jenkins_metrics.queue_size // "N/A") | Executors: \(.jenkins_metrics.executors_busy // "N/A")/\(.jenkins_metrics.executors_total // "N/A")"' "${METRICS_FILE}" | while read -r line; do
            log "  ${line}"
        done
    else
        log "No metrics file found. Run monitoring first."
        return 1
    fi
}

# Usage function
usage() {
    echo "Usage: $0 [command] [team]"
    echo ""
    echo "Commands:"
    echo "  monitor [team]     Monitor all teams or specific team"
    echo "  summary           Generate summary report from latest metrics"
    echo ""
    echo "Examples:"
    echo "  $0 monitor        # Monitor all teams"
    echo "  $0 monitor devops # Monitor devops team only"
    echo "  $0 summary        # Generate summary report"
    echo ""
    echo "Available teams: {% for team in jenkins_teams %}{{ team.name }}{% if not loop.last %}, {% endif %}{% endfor %}"
}

# Main execution
main() {
    local command="${1:-monitor}"
    
    case "${command}" in
        "monitor")
            if [ $# -eq 2 ]; then
                monitor_team "$2"
            else
                monitor_all_teams
            fi
            ;;
        "summary")
            generate_summary
            ;;
        *)
            usage
            exit 1
            ;;
    esac
}

# Execute main function with all arguments
main "$@"