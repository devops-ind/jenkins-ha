#!/bin/bash
# keepalived HAProxy Health Check Script
# Comprehensive health monitoring for containerized HAProxy
# Generated by Ansible high-availability role

set -euo pipefail

# Configuration
HAPROXY_STATS_PORT="{{ haproxy_stats_port | default('8404') }}"
HAPROXY_STATS_URI="{{ haproxy_stats_uri | default('/stats') }}"
HAPROXY_CONTAINER_NAME="jenkins-haproxy"
LOG_FILE="/var/log/keepalived-haproxy-check.log"
TIMEOUT=8

# Logging function
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [keepalived-check] $1" | tee -a "$LOG_FILE"
}

# Check if HAProxy container is running
check_container_running() {
    if ! {{ haproxy_container_runtime }} ps --filter "name=${HAPROXY_CONTAINER_NAME}" --filter "status=running" --format "table {% raw %}{{.Names}}{% endraw %}" | grep -q "${HAPROXY_CONTAINER_NAME}"; then
        log_message "ERROR: HAProxy container '${HAPROXY_CONTAINER_NAME}' is not running"
        return 1
    fi
    return 0
}

# Check HAProxy stats endpoint
check_haproxy_stats() {
    local stats_url="http://localhost:${HAPROXY_STATS_PORT}${HAPROXY_STATS_URI}"
    
    if ! curl -f -s --max-time "$TIMEOUT" "$stats_url" >/dev/null 2>&1; then
        log_message "ERROR: HAProxy stats endpoint unreachable: $stats_url"
        return 1
    fi
    return 0
}

# Check HAProxy backend health via stats API
check_backend_health() {
    local stats_api_url="http://localhost:${HAPROXY_STATS_PORT}/stats;csv"
    
    # Get backend status - look for any UP backends
    local backend_status
    if ! backend_status=$(curl -f -s --max-time "$TIMEOUT" "$stats_api_url" 2>/dev/null); then
        log_message "ERROR: Cannot retrieve HAProxy backend status"
        return 1
    fi
    
    # Check if we have any UP backends (excluding stats)
    local up_backends
    up_backends=$(echo "$backend_status" | grep -v "^stats," | grep ",UP," | wc -l)
    
    if [ "$up_backends" -eq 0 ]; then
        log_message "WARNING: No UP backends found in HAProxy"
        # Don't fail completely - HAProxy might be starting or Jenkins containers restarting
        # Just log warning and continue
    fi
    
    return 0
}

# Check if HAProxy process is responsive inside container
check_haproxy_process() {
    local haproxy_pid
    if ! haproxy_pid=$({{ haproxy_container_runtime }} exec "${HAPROXY_CONTAINER_NAME}" pgrep haproxy 2>/dev/null); then
        log_message "ERROR: HAProxy process not found in container"
        return 1
    fi
    
    # Check if process is responsive
    if ! {{ haproxy_container_runtime }} exec "${HAPROXY_CONTAINER_NAME}" kill -0 "$haproxy_pid" 2>/dev/null; then
        log_message "ERROR: HAProxy process not responsive (PID: $haproxy_pid)"
        return 1
    fi
    
    return 0
}

# Main health check function
main() {
    local exit_code=0
    
    # Rotate log file if it gets too large (>10MB)
    if [ -f "$LOG_FILE" ] && [ $(stat -f%%z "$LOG_FILE" 2>/dev/null || stat -c%%s "$LOG_FILE" 2>/dev/null || echo 0) -gt 10485760 ]; then
        mv "$LOG_FILE" "${LOG_FILE}.old"
        touch "$LOG_FILE"
    fi
    
    # Run all health checks
    if ! check_container_running; then
        exit_code=1
    elif ! check_haproxy_process; then
        exit_code=1
    elif ! check_haproxy_stats; then
        exit_code=1
    elif ! check_backend_health; then
        # Backend health is a warning, not a failure
        exit_code=0
    fi
    
    if [ $exit_code -eq 0 ]; then
        # Only log success occasionally to avoid log spam
        if [ $(($(date +%%s) %% 30)) -eq 0 ]; then
            log_message "SUCCESS: HAProxy health check passed"
        fi
    else
        log_message "FAILURE: HAProxy health check failed (exit code: $exit_code)"
    fi
    
    exit $exit_code
}

# Handle script interruption
trap 'log_message "Health check interrupted"; exit 1' INT TERM

# Execute main function
main "$@"