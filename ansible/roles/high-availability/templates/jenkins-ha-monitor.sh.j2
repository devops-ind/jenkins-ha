#!/bin/bash
# Jenkins Multi-Team HA Monitoring Script
# Generated by Ansible high-availability role

set -euo pipefail

# Configuration
HAPROXY_CONTAINER="jenkins-haproxy"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
HEALTH_CHECK_SCRIPT="$SCRIPT_DIR/jenkins-ha-healthcheck.sh"
LOG_FILE="{{ monitoring_log_file | default('/var/log/jenkins-ha-monitor.log') }}"
ALERT_THRESHOLD={{ monitoring_alert_threshold | default(3) }}
STATS_URL="http://{{ ansible_default_ipv4.address }}:{{ haproxy_stats_port | default(8404) }}/stats;csv"

# State tracking
STATE_FILE="/tmp/jenkins-ha-monitor.state"
FAILURE_COUNT_FILE="/tmp/jenkins-ha-failures.count"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [MONITOR] $1" | tee -a "$LOG_FILE"
}

# Get HAProxy backend statistics
get_backend_stats() {
    local backend="$1"
    
    if ! curl -sf --connect-timeout 5 "$STATS_URL" 2>/dev/null | grep "^$backend,"; then
        return 1
    fi
}

# Check individual backend health
check_backend_health() {
    local backend="$1"
    local stats
    
    if stats=$(get_backend_stats "$backend"); then
        local status=$(echo "$stats" | cut -d',' -f18)  # Status field
        local active_servers=$(echo "$stats" | grep -c ",UP,")
        
        echo "Backend: $backend, Status: $status, Active Servers: $active_servers"
        log "Backend $backend: $status ($active_servers active servers)"
        
        if [ "$status" = "UP" ] && [ "$active_servers" -gt 0 ]; then
            return 0
        fi
    fi
    
    return 1
}

# Update failure counter
update_failure_count() {
    local current_count=0
    
    if [ -f "$FAILURE_COUNT_FILE" ]; then
        current_count=$(cat "$FAILURE_COUNT_FILE")
    fi
    
    if [ "$1" = "increment" ]; then
        ((current_count++))
    elif [ "$1" = "reset" ]; then
        current_count=0
    fi
    
    echo "$current_count" > "$FAILURE_COUNT_FILE"
    echo "$current_count"
}

# Send alert if threshold exceeded
check_alert_threshold() {
    local failure_count
    failure_count=$(cat "$FAILURE_COUNT_FILE" 2>/dev/null || echo "0")
    
    if [ "$failure_count" -ge "$ALERT_THRESHOLD" ]; then
        log "ALERT: Failure threshold exceeded ($failure_count >= $ALERT_THRESHOLD)"
        
        {% if failover_notification_enabled | default(false) %}
        # Send notification
        local alert_msg="Jenkins HA Alert: $failure_count consecutive failures detected at $(date)"
        
        if command -v mail >/dev/null 2>&1 && [ -n "${ALERT_EMAIL:-}" ]; then
            echo "$alert_msg" | mail -s "Jenkins HA Critical Alert" "$ALERT_EMAIL"
            log "Alert notification sent to $ALERT_EMAIL"
        fi
        
        # Webhook notification if configured
        if [ -n "${ALERT_WEBHOOK:-}" ]; then
            curl -X POST "$ALERT_WEBHOOK" \
                -H "Content-Type: application/json" \
                -d "{\"text\":\"$alert_msg\"}" \
                >/dev/null 2>&1 || true
            log "Alert webhook notification sent"
        fi
        {% endif %}
        
        {% if failover_enabled | default(true) %}
        # Trigger failover script if available
        if [ -x "$SCRIPT_DIR/jenkins-failover.sh" ]; then
            log "Triggering automated failover"
            "$SCRIPT_DIR/jenkins-failover.sh" || log "Failover script failed"
        fi
        {% endif %}
        
        return 0
    fi
    
    return 1
}

# Main monitoring loop
main() {
    log "Starting Jenkins HA monitoring check"
    
    # Run comprehensive health check
    if "$HEALTH_CHECK_SCRIPT"; then
        log "Health check passed"
        update_failure_count "reset" >/dev/null
        
        # Update state file
        echo "$(date '+%Y-%m-%d %H:%M:%S'): HEALTHY" > "$STATE_FILE"
        
    else
        log "Health check failed"
        local failure_count
        failure_count=$(update_failure_count "increment")
        
        # Update state file
        echo "$(date '+%Y-%m-%d %H:%M:%S'): UNHEALTHY (failures: $failure_count)" > "$STATE_FILE"
        
        # Check if we need to alert/failover
        check_alert_threshold
    fi
    
    # Check individual backends
    echo ""
    log "Checking individual backends:"
    
    {% if jenkins_teams is defined and jenkins_teams | length > 0 %}
    {% for team in jenkins_teams %}
    check_backend_health "jenkins_backend_{{ team.team_name }}" || log "Backend jenkins_backend_{{ team.team_name }} unhealthy"
    {% endfor %}
    {% else %}
    # Default backends
    check_backend_health "jenkins_backend_default" || log "Backend jenkins_backend_default unhealthy"
    check_backend_health "jenkins_backend_dev" || log "Backend jenkins_backend_dev unhealthy"  
    check_backend_health "jenkins_backend_staging" || log "Backend jenkins_backend_staging unhealthy"
    check_backend_health "jenkins_backend_prod" || log "Backend jenkins_backend_prod unhealthy"
    {% endif %}
    
    # Generate status summary
    local uptime
    uptime=$(uptime | awk '{print $3,$4}' | sed 's/,//')
    
    log "Monitoring cycle completed. System uptime: $uptime"
    
    # Cleanup old log entries (keep last 1000 lines)
    if [ -f "$LOG_FILE" ] && [ $(wc -l < "$LOG_FILE") -gt 1000 ]; then
        tail -1000 "$LOG_FILE" > "${LOG_FILE}.tmp" && mv "${LOG_FILE}.tmp" "$LOG_FILE"
        log "Log file rotated"
    fi
}

# Handle script termination
trap 'log "Monitoring script interrupted"; exit 1' INT TERM

# Execute main function
main "$@"