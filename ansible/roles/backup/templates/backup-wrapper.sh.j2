#!/bin/bash
# Backup Wrapper Script
# Provides operational modes for backup management
# Generated by Ansible backup role

set -euo pipefail

# Source configuration
source {{ backup_home_dir }}/backup-config.env

# Script information
SCRIPT_NAME="$(basename "$0")"
SCRIPT_VERSION="1.0.0"
LOG_FILE="{{ backup_log_file }}"
WRAPPER_LOG="/var/log/jenkins-backup/wrapper.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${timestamp} [${level}] ${message}" | tee -a "${WRAPPER_LOG}"
}

log_info() {
    log "INFO" "$*"
    echo -e "${BLUE}ℹ️  $*${NC}"
}

log_success() {
    log "SUCCESS" "$*"
    echo -e "${GREEN}✅ $*${NC}"
}

log_warning() {
    log "WARNING" "$*"
    echo -e "${YELLOW}⚠️  $*${NC}"
}

log_error() {
    log "ERROR" "$*"
    echo -e "${RED}❌ $*${NC}"
}

# Usage function
usage() {
    cat << EOF
Usage: $0 <MODE> [OPTIONS]

Simplified Jenkins Backup Wrapper - Critical Data Only

MODES:
    daily       Execute daily critical data backup
    cleanup     Clean up old backups and temporary files
    verify      Verify backup integrity for all teams
    monitor     Generate monitoring metrics
    status      Show backup system status
    restore     Restore critical data for specific team
    test        Test backup functionality (dry run)

OPTIONS:
    -t, --team TEAM     Specific team (for restore mode)
    -d, --date DATE     Backup date for restore (YYYYMMDD_HHMMSS)
    -v, --verbose       Enable verbose logging
    -h, --help          Show this help message

EXAMPLES:
    $0 daily                    # Run daily backup for all teams
    $0 cleanup                  # Clean up old backups
    $0 verify                   # Verify all team backups
    $0 status                   # Show backup system status
    $0 restore -t devops        # Restore latest backup for devops team
    $0 test -v                  # Test backup with verbose output

STORAGE REDUCTION:
    This simplified approach provides 99% storage reduction by backing up
    only critical data that cannot be recreated from code.

EOF
}

# Backup operations
execute_daily_backup() {
    log_info "Starting daily critical data backup"
    
    if [[ ! -x "$BACKUP_SCRIPT_PATH" ]]; then
        log_error "Backup script not found or not executable: $BACKUP_SCRIPT_PATH"
        return 1
    fi
    
    log_info "Executing backup for teams: $JENKINS_TEAMS"
    
    if "$BACKUP_SCRIPT_PATH" \
        --teams "$JENKINS_TEAMS" \
        --backup-dir "$BACKUP_BASE_DIR" \
        --retention "$RETENTION_DAYS" \
        --log-file "$LOG_FILE"; then
        log_success "Daily backup completed successfully"
        
        # Update backup status
        echo "{\"status\": \"success\", \"timestamp\": \"$(date -Iseconds)\", \"type\": \"daily\"}" > "$BACKUP_BASE_DIR/backup-status.json"
        
        # Send success notification if enabled
        if [[ "$BACKUP_NOTIFICATIONS_ENABLED" == "true" ]] && [[ "$BACKUP_NOTIFICATION_ON_SUCCESS" == "true" ]]; then
            send_notification "success" "Daily backup completed successfully"
        fi
        
        return 0
    else
        log_error "Daily backup failed"
        
        # Update backup status
        echo "{\"status\": \"failed\", \"timestamp\": \"$(date -Iseconds)\", \"type\": \"daily\"}" > "$BACKUP_BASE_DIR/backup-status.json"
        
        # Send failure notification
        if [[ "$BACKUP_NOTIFICATIONS_ENABLED" == "true" ]] && [[ "$BACKUP_NOTIFICATION_ON_FAILURE" == "true" ]]; then
            send_notification "failure" "Daily backup failed"
        fi
        
        return 1
    fi
}

execute_cleanup() {
    log_info "Starting backup cleanup"
    
    local cleanup_count=0
    
    # Clean up old backup files
    for team in $JENKINS_TEAMS; do
        local team_dir="$BACKUP_BASE_DIR/$team"
        if [[ -d "$team_dir" ]]; then
            local old_backups
            old_backups=$(find "$team_dir" -name "critical-data-*.tar.gz" -type f -mtime +$RETENTION_DAYS)
            if [[ -n "$old_backups" ]]; then
                echo "$old_backups" | xargs rm -f
                local count
                count=$(echo "$old_backups" | wc -l)
                cleanup_count=$((cleanup_count + count))
                log_info "Cleaned up $count old backups for team $team"
            fi
        fi
    done
    
    # Clean up old markers and reports
    find "$BACKUP_BASE_DIR" -name ".backup-completed-*" -type f -mtime +7 -delete 2>/dev/null || true
    find "$BACKUP_BASE_DIR" -name "backup-summary-*.json" -type f -mtime +$RETENTION_DAYS -delete 2>/dev/null || true
    
    log_success "Cleanup completed. Removed $cleanup_count old backup files"
    return 0
}

execute_verify() {
    log_info "Starting backup verification"
    
    local success_count=0
    local total_count=0
    
    for team in $JENKINS_TEAMS; do
        local team_dir="$BACKUP_BASE_DIR/$team"
        if [[ -d "$team_dir" ]]; then
            # Find latest backup for team
            local latest_backup
            latest_backup=$(find "$team_dir" -name "critical-data-*.tar.gz" -type f -printf "%T@ %p\n" | sort -n | tail -1 | cut -d' ' -f2-)
            
            if [[ -n "$latest_backup" ]]; then
                total_count=$((total_count + 1))
                log_info "Verifying backup for team $team: $(basename "$latest_backup")"
                
                if tar -tzf "$latest_backup" >/dev/null 2>&1; then
                    success_count=$((success_count + 1))
                    log_success "Verification passed for team $team"
                else
                    log_error "Verification failed for team $team"
                fi
            else
                log_warning "No backups found for team $team"
            fi
        fi
    done
    
    log_info "Verification completed: $success_count/$total_count backups verified"
    
    if [[ $success_count -eq $total_count ]]; then
        log_success "All backups verified successfully"
        return 0
    else
        log_error "Some backup verifications failed"
        return 1
    fi
}

execute_monitor() {
    log_info "Generating monitoring metrics"
    
    # Execute monitoring script if it exists
    if [[ -x "{{ backup_home_dir }}/scripts/backup-metrics.sh" ]]; then
        "{{ backup_home_dir }}/scripts/backup-metrics.sh"
        log_success "Monitoring metrics updated"
    else
        log_warning "Monitoring script not found"
    fi
    
    return 0
}

show_status() {
    log_info "Backup System Status"
    echo "========================"
    echo "Backup Enabled: {{ backup_enabled }}"
    echo "Backup Method: {{ backup_method }}"
    echo "Backup Strategy: {{ backup_strategy }}"
    echo "Teams: $JENKINS_TEAMS"
    echo "Retention: $RETENTION_DAYS days"
    echo "Storage Location: $BACKUP_BASE_DIR"
    echo ""
    
    # Storage usage
    if [[ -d "$BACKUP_BASE_DIR" ]]; then
        local total_size
        total_size=$(du -sh "$BACKUP_BASE_DIR" 2>/dev/null | cut -f1 || echo "Unknown")
        echo "Total Storage Used: $total_size"
    fi
    
    # Team status
    echo ""
    echo "Team Status:"
    for team in $JENKINS_TEAMS; do
        local team_dir="$BACKUP_BASE_DIR/$team"
        if [[ -d "$team_dir" ]]; then
            local backup_count
            backup_count=$(find "$team_dir" -name "critical-data-*.tar.gz" | wc -l)
            local team_size
            team_size=$(du -sh "$team_dir" 2>/dev/null | cut -f1 || echo "Unknown")
            echo "  $team: $backup_count backups, $team_size"
        else
            echo "  $team: No backups found"
        fi
    done
    
    return 0
}

send_notification() {
    local status="$1"
    local message="$2"
    
    # Webhook notification
    if [[ -n "${BACKUP_WEBHOOK_URL:-}" ]]; then
        curl -s -X POST "$BACKUP_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{\"text\": \"Jenkins Backup $status: $message\"}" || true
    fi
    
    # Email notification (if configured)
    if [[ -n "${BACKUP_NOTIFICATION_EMAIL:-}" ]]; then
        echo "$message" | mail -s "Jenkins Backup $status" "$BACKUP_NOTIFICATION_EMAIL" || true
    fi
}

# Parse command line arguments
MODE=""
TEAM=""
DATE=""
VERBOSE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        daily|cleanup|verify|monitor|status|restore|test)
            MODE="$1"
            shift
            ;;
        -t|--team)
            TEAM="$2"
            shift 2
            ;;
        -d|--date)
            DATE="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Validate mode
if [[ -z "$MODE" ]]; then
    log_error "Mode is required"
    usage
    exit 1
fi

# Set verbose logging
if [[ "$VERBOSE" == "true" ]]; then
    set -x
fi

# Create log directory
mkdir -p "$(dirname "$WRAPPER_LOG")"

# Execute mode
log_info "Starting backup wrapper: mode=$MODE, team=$TEAM, date=$DATE"

case "$MODE" in
    daily)
        execute_daily_backup
        ;;
    cleanup)
        execute_cleanup
        ;;
    verify)
        execute_verify
        ;;
    monitor)
        execute_monitor
        ;;
    status)
        show_status
        ;;
    restore)
        log_error "Restore functionality not yet implemented"
        exit 1
        ;;
    test)
        log_info "Test mode - would execute daily backup (dry run)"
        BACKUP_SCRIPT_PATH="$BACKUP_SCRIPT_PATH --dry-run"
        execute_daily_backup
        ;;
    *)
        log_error "Unknown mode: $MODE"
        usage
        exit 1
        ;;
esac

exit_code=$?
log_info "Backup wrapper completed with exit code: $exit_code"
exit $exit_code