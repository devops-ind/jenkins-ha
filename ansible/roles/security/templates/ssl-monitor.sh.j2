#!/bin/bash
# SSL Certificate Monitoring Script
# Generated by Ansible - Jenkins HA Infrastructure

set -euo pipefail

# Configuration
CERT_DIR="{{ ssl_certificate_dir }}"
LOG_FILE="/var/log/ssl-monitor.log"
ALERT_EMAIL="{{ vault_ssl_email | default('') }}"
RENEWAL_THRESHOLD={{ ssl_renewal_threshold_days }}
SLACK_WEBHOOK="{{ vault_slack_webhook_url | default('') }}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging function
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

# Send alert function
send_alert() {
    local subject="$1"
    local message="$2"
    local severity="$3"
    
    # Email alert
    if [[ -n "$ALERT_EMAIL" ]]; then
        echo -e "$message" | mail -s "$subject" "$ALERT_EMAIL" || true
    fi
    
    # Slack alert
    if [[ -n "$SLACK_WEBHOOK" ]]; then
        local color="good"
        case "$severity" in
            "critical") color="danger" ;;
            "warning") color="warning" ;;
            "info") color="good" ;;
        esac
        
        curl -s -X POST "$SLACK_WEBHOOK" \
            -H 'Content-type: application/json' \
            --data "{
                \"attachments\": [{
                    \"color\": \"$color\",
                    \"title\": \"$subject\",
                    \"text\": \"$message\",
                    \"footer\": \"Jenkins HA SSL Monitor\",
                    \"ts\": $(date +%s)
                }]
            }" || true
    fi
}

# Check certificate expiration
check_certificate_expiration() {
    local cert_path="$1"
    local service_name="$2"
    
    if [[ ! -f "$cert_path" ]]; then
        log_message "ERROR" "Certificate not found: $cert_path"
        return 1
    fi
    
    local expiry_date=$(openssl x509 -in "$cert_path" -noout -enddate | cut -d= -f2)
    local expiry_epoch=$(date -d "$expiry_date" +%s)
    local current_epoch=$(date +%s)
    local days_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))
    
    log_message "INFO" "Certificate $service_name expires in $days_until_expiry days"
    
    if [[ $days_until_expiry -lt 0 ]]; then
        log_message "CRITICAL" "Certificate $service_name has EXPIRED!"
        send_alert "CRITICAL: SSL Certificate Expired" \
            "Certificate for $service_name has expired on $expiry_date" \
            "critical"
        return 2
    elif [[ $days_until_expiry -lt $RENEWAL_THRESHOLD ]]; then
        log_message "WARNING" "Certificate $service_name expires in $days_until_expiry days (threshold: $RENEWAL_THRESHOLD)"
        send_alert "WARNING: SSL Certificate Renewal Required" \
            "Certificate for $service_name expires in $days_until_expiry days. Renewal required." \
            "warning"
        return 1
    else
        log_message "INFO" "Certificate $service_name is valid for $days_until_expiry days"
        return 0
    fi
}

# Validate certificate chain
validate_certificate_chain() {
    local cert_path="$1"
    local ca_path="{{ ssl_ca_certificate_path }}"
    local service_name="$2"
    
    if openssl verify -CAfile "$ca_path" "$cert_path" >/dev/null 2>&1; then
        log_message "INFO" "Certificate chain for $service_name is valid"
        return 0
    else
        log_message "ERROR" "Certificate chain for $service_name is INVALID"
        send_alert "ERROR: Invalid SSL Certificate Chain" \
            "Certificate chain validation failed for $service_name" \
            "critical"
        return 1
    fi
}

# Check certificate key pair
check_certificate_key_pair() {
    local cert_path="$1"
    local key_path="$2"
    local service_name="$3"
    
    if [[ ! -f "$key_path" ]]; then
        log_message "ERROR" "Private key not found: $key_path"
        return 1
    fi
    
    local cert_modulus=$(openssl x509 -noout -modulus -in "$cert_path" | openssl md5)
    local key_modulus=$(openssl rsa -noout -modulus -in "$key_path" 2>/dev/null | openssl md5)
    
    if [[ "$cert_modulus" == "$key_modulus" ]]; then
        log_message "INFO" "Certificate and key pair for $service_name match"
        return 0
    else
        log_message "ERROR" "Certificate and key pair for $service_name do NOT match"
        send_alert "ERROR: SSL Certificate Key Mismatch" \
            "Certificate and private key do not match for $service_name" \
            "critical"
        return 1
    fi
}

# Check SSL service endpoints
check_ssl_endpoints() {
    local services=(
{% for service in ssl_services %}
        "{{ service.name }}:{{ service.common_name }}:{{ service.port | default('443') }}"
{% endfor %}
    )
    
    for service_info in "${services[@]}"; do
        IFS=':' read -r service_name hostname port <<< "$service_info"
        
        log_message "INFO" "Checking SSL endpoint: $hostname:$port"
        
        # Test SSL connection
        if timeout 10 openssl s_client -connect "$hostname:$port" -servername "$hostname" </dev/null >/dev/null 2>&1; then
            log_message "INFO" "SSL endpoint $hostname:$port is accessible"
            
            # Get certificate from endpoint
            local remote_cert=$(timeout 10 openssl s_client -connect "$hostname:$port" -servername "$hostname" </dev/null 2>/dev/null | openssl x509 -outform PEM)
            local local_cert_path="$CERT_DIR/$service_name.crt"
            
            if [[ -f "$local_cert_path" ]]; then
                local local_cert=$(cat "$local_cert_path")
                if [[ "$remote_cert" == "$local_cert" ]]; then
                    log_message "INFO" "Remote certificate matches local certificate for $service_name"
                else
                    log_message "WARNING" "Remote certificate differs from local certificate for $service_name"
                fi
            fi
        else
            log_message "ERROR" "SSL endpoint $hostname:$port is NOT accessible"
            send_alert "ERROR: SSL Endpoint Unreachable" \
                "SSL endpoint $hostname:$port for $service_name is not accessible" \
                "critical"
        fi
    done
}

# Main certificate monitoring function
monitor_certificates() {
    log_message "INFO" "Starting SSL certificate monitoring"
    
    local overall_status=0
    local services=(
{% for service in ssl_services %}
        "{{ service.name }}"
{% endfor %}
    )
    
    for service in "${services[@]}"; do
        local cert_path="$CERT_DIR/$service.crt"
        local key_path="{{ ssl_private_key_dir }}/$service.key"
        
        log_message "INFO" "Checking certificate for service: $service"
        
        # Check expiration
        if ! check_certificate_expiration "$cert_path" "$service"; then
            overall_status=1
        fi
        
        # Validate chain
        if ! validate_certificate_chain "$cert_path" "$service"; then
            overall_status=1
        fi
        
        # Check key pair
        if ! check_certificate_key_pair "$cert_path" "$key_path" "$service"; then
            overall_status=1
        fi
    done
    
    # Check SSL endpoints if requested
    if [[ "${1:-}" == "--check-endpoints" ]]; then
        check_ssl_endpoints
    fi
    
    if [[ $overall_status -eq 0 ]]; then
        log_message "INFO" "All SSL certificates are healthy"
    else
        log_message "WARNING" "Some SSL certificates require attention"
    fi
    
    return $overall_status
}

# Certificate renewal function
renew_certificates() {
    log_message "INFO" "Starting certificate renewal process"
    
{% if ssl_use_letsencrypt | default(false) %}
    # Let's Encrypt renewal
    if command -v certbot >/dev/null 2>&1; then
        log_message "INFO" "Renewing Let's Encrypt certificates"
        if certbot renew --quiet; then
            log_message "INFO" "Let's Encrypt certificates renewed successfully"
            send_alert "INFO: SSL Certificates Renewed" \
                "Let's Encrypt certificates have been renewed successfully" \
                "info"
        else
            log_message "ERROR" "Let's Encrypt certificate renewal failed"
            send_alert "ERROR: SSL Certificate Renewal Failed" \
                "Let's Encrypt certificate renewal failed" \
                "critical"
        fi
    fi
{% else %}
    # Self-signed certificate renewal
    log_message "INFO" "Self-signed certificate renewal not automated"
    log_message "INFO" "Please regenerate certificates manually if needed"
{% endif %}
}

# Show help
show_help() {
    cat << EOF
SSL Certificate Monitoring Script

Usage: $0 [OPTIONS]

Options:
    --check-renewal     Check certificates and renew if needed
    --check-endpoints   Check SSL endpoints accessibility
    --monitor          Monitor all certificates
    --renew            Attempt to renew certificates
    --help             Show this help message

Examples:
    $0 --monitor                    # Monitor all certificates
    $0 --check-renewal             # Check and renew if needed
    $0 --monitor --check-endpoints # Monitor certificates and endpoints

EOF
}

# Main execution
main() {
    case "${1:-}" in
        "--check-renewal")
            monitor_certificates
            if [[ $? -ne 0 ]]; then
                renew_certificates
            fi
            ;;
        "--check-endpoints")
            check_ssl_endpoints
            ;;
        "--monitor")
            monitor_certificates "$@"
            ;;
        "--renew")
            renew_certificates
            ;;
        "--help"|"-h")
            show_help
            ;;
        *)
            monitor_certificates
            ;;
    esac
}

# Execute main function
main "$@"