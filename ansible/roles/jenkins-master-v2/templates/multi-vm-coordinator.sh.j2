#!/bin/bash
# Multi-VM/Container Coordinator for Jenkins HA Infrastructure
# Handles coordination across multiple VMs or containers during upgrades

set -euo pipefail

# Configuration
TEAM_NAME="{{ item.team_name }}"
JENKINS_HOME="{{ jenkins_home_dir }}"
CONFIG_DIR="{{ jenkins_master_custom_build_dir }}"
STATE_FILE="${CONFIG_DIR}/${TEAM_NAME}/blue-green-state.json"
COORDINATOR_PORT="{{ multi_vm_coordinator_port | default(8765) }}"
CONSENSUS_TIMEOUT="{{ consensus_timeout | default(300) }}"
HEARTBEAT_INTERVAL="{{ heartbeat_interval | default(30) }}"
COORDINATOR_STATE_DIR="${CONFIG_DIR}/coordination"
CONTAINER_RUNTIME="{{ jenkins_master_container_runtime | default('docker') }}"

# Team-specific configuration
BLUE_CONTAINER="jenkins-${TEAM_NAME}-blue"
GREEN_CONTAINER="jenkins-${TEAM_NAME}-green"
TEAM_CONFIG_PATH="${CONFIG_DIR}/${TEAM_NAME}"

# Architecture detection
VMS=({% for host in groups['jenkins_masters'] %}"{{ host }}"{% if not loop.last %} {% endif %}{% endfor %})
LOCAL_VM="{{ ansible_hostname }}"
VM_COUNT=${#VMS[@]}

# Determine deployment mode
if [[ $VM_COUNT -eq 1 ]]; then
    DEPLOYMENT_MODE="container"
    log "Detected container-based deployment (single VM: ${VMS[0]})"
    # Container-based coordination
    CONTAINERS=("$BLUE_CONTAINER" "$GREEN_CONTAINER")
    IS_COORDINATOR="true"  # Single VM is always coordinator
else
    DEPLOYMENT_MODE="multi_vm"
    log "Detected multi-VM deployment ($VM_COUNT VMs)"
    IS_COORDINATOR="{{ 'true' if ansible_hostname == groups['jenkins_masters'][0] else 'false' }}"
fi

# Colors and formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Logging functions
log() { echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
warn() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
info() { echo -e "${CYAN}[INFO]${NC} $1"; }

# Coordination state
COORDINATION_ID=""
OPERATION_TYPE=""
VOTE_RESULTS=""
CONSENSUS_REACHED=false
READY_VMS=()
FAILED_VMS=()

# Display usage
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

OPTIONS:
    --operation TYPE            Operation type: upgrade, switch, rollback, maintenance
    --team TEAM                 Team name
    --environment ENV           Target environment
    --upgrade-type TYPE         Upgrade type: jenkins_version, plugins, job_dsl, infrastructure
    --coordination-id ID        Unique coordination session ID
    --timeout SECONDS           Consensus timeout (default: $CONSENSUS_TIMEOUT)
    --force                     Force operation without full consensus
    --status                    Show coordination status
    --cleanup                   Clean up coordination state
    --help                      Show this help

OPERATIONS:
    initiate                    Initiate coordination session (coordinator only)
    join                        Join coordination session (participant)
    vote                        Cast vote for operation
    consensus                   Check consensus status
    execute                     Execute coordinated operation
    abort                       Abort coordination session

EXAMPLES:
    # Initiate Jenkins version upgrade coordination
    $0 --operation upgrade --team devops --environment green \
       --upgrade-type jenkins_version --coordination-id upgrade-$(date +%s)
    
    # Join coordination session as participant
    $0 join --coordination-id upgrade-1234567890
    
    # Check consensus status
    $0 consensus --coordination-id upgrade-1234567890

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --operation)
                OPERATION_TYPE="$2"
                shift 2
                ;;
            --team)
                TEAM_NAME="$2"
                shift 2
                ;;
            --environment)
                TARGET_ENVIRONMENT="$2"
                shift 2
                ;;
            --upgrade-type)
                UPGRADE_TYPE="$2"
                shift 2
                ;;
            --coordination-id)
                COORDINATION_ID="$2"
                shift 2
                ;;
            --timeout)
                CONSENSUS_TIMEOUT="$2"
                shift 2
                ;;
            --force)
                FORCE_OPERATION=true
                shift
                ;;
            --status)
                SHOW_STATUS=true
                shift
                ;;
            --cleanup)
                CLEANUP_STATE=true
                shift
                ;;
            initiate|join|vote|consensus|execute|abort)
                COMMAND="$1"
                shift
                ;;
            --help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
}

# Initialize coordination state directory
init_coordination_state() {
    mkdir -p "$COORDINATOR_STATE_DIR"
    
    if [[ ! -f "$COORDINATOR_STATE_DIR/vm-inventory.json" ]]; then
        cat <<EOF > "$COORDINATOR_STATE_DIR/vm-inventory.json"
{
    "vms": $(printf '%s\n' "${VMS[@]}" | jq -R . | jq -s .),
    "coordinator": "${VMS[0]}",
    "total_vms": ${#VMS[@]},
    "quorum_size": $(( (${#VMS[@]} / 2) + 1 ))
}
EOF
    fi
}

# Send coordination message (VM or container mode)
send_coordination_message() {
    local target_vm="$1"
    local message="$2"
    local timeout="${3:-30}"
    
    if [[ "$DEPLOYMENT_MODE" == "container" ]]; then
        # Container mode: all operations are local
        echo "$message" | process_coordination_message
        return $?
    fi
    
    if [[ "$target_vm" == "$LOCAL_VM" ]]; then
        # Local message processing
        echo "$message" | process_coordination_message
        return $?
    fi
    
    # Remote message via SSH (multi-VM mode)
    timeout "$timeout" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no \
        "$target_vm" "echo '$message' | bash -s" 2>/dev/null || return 1
}

# Broadcast message (VM or container mode)
broadcast_message() {
    local message="$1"
    local successful_sends=0
    
    if [[ "$DEPLOYMENT_MODE" == "container" ]]; then
        # Container mode: single host coordination
        log "Processing message locally (container mode)..."
        if echo "$message" | process_coordination_message; then
            success "Message processed successfully in container mode"
            return 0
        else
            error "Failed to process message in container mode"
            return 1
        fi
    fi
    
    # Multi-VM mode: broadcast to all VMs
    log "Broadcasting message to ${#VMS[@]} VMs..."
    
    for vm in "${VMS[@]}"; do
        if send_coordination_message "$vm" "$message" 15; then
            ((successful_sends++))
            info "Message sent successfully to $vm"
        else
            warn "Failed to send message to $vm"
        fi
    done
    
    log "Message broadcast completed: $successful_sends/${#VMS[@]} successful"
    return $(( successful_sends >= $(( (${#VMS[@]} / 2) + 1 )) ? 0 : 1 ))
}

# Process incoming coordination message
process_coordination_message() {
    local message
    read -r message
    
    local msg_type=$(echo "$message" | jq -r '.type')
    local coordination_id=$(echo "$message" | jq -r '.coordination_id')
    
    case "$msg_type" in
        "coordination_request")
            process_coordination_request "$message"
            ;;
        "vote_request")
            process_vote_request "$message"
            ;;
        "consensus_notification")
            process_consensus_notification "$message"
            ;;
        "execution_command")
            process_execution_command "$message"
            ;;
        "heartbeat")
            process_heartbeat "$message"
            ;;
        *)
            warn "Unknown message type: $msg_type"
            ;;
    esac
}

# Initiate coordination session
initiate_coordination() {
    if [[ "$IS_COORDINATOR" != "true" ]]; then
        error "Only the coordinator VM can initiate coordination sessions"
        return 1
    fi
    
    log "Initiating coordination session: $COORDINATION_ID"
    
    # Create coordination session
    local session_data=$(cat <<EOF
{
    "coordination_id": "$COORDINATION_ID",
    "operation_type": "$OPERATION_TYPE",
    "team": "$TEAM_NAME",
    "environment": "${TARGET_ENVIRONMENT:-}",
    "upgrade_type": "${UPGRADE_TYPE:-}",
    "initiated_by": "$LOCAL_VM",
    "initiated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "status": "initiated",
    "participants": [],
    "votes": {},
    "consensus_reached": false
}
EOF
)
    
    echo "$session_data" > "$COORDINATOR_STATE_DIR/session-${COORDINATION_ID}.json"
    
    # Broadcast coordination request
    local coordination_request=$(cat <<EOF
{
    "type": "coordination_request",
    "coordination_id": "$COORDINATION_ID",
    "operation_type": "$OPERATION_TYPE",
    "team": "$TEAM_NAME",
    "environment": "${TARGET_ENVIRONMENT:-}",
    "upgrade_type": "${UPGRADE_TYPE:-}",
    "coordinator": "$LOCAL_VM",
    "timeout": $CONSENSUS_TIMEOUT
}
EOF
)
    
    if broadcast_message "$coordination_request"; then
        success "Coordination session initiated successfully"
        
        # Start heartbeat monitoring
        start_heartbeat_monitor
        
        return 0
    else
        error "Failed to broadcast coordination request"
        return 1
    fi
}

# Join coordination session
join_coordination() {
    log "Joining coordination session: $COORDINATION_ID"
    
    # Send join response to coordinator
    local join_response=$(cat <<EOF
{
    "type": "join_response",
    "coordination_id": "$COORDINATION_ID",
    "vm": "$LOCAL_VM",
    "status": "ready",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
)
    
    local coordinator="${VMS[0]}"
    if send_coordination_message "$coordinator" "$join_response"; then
        success "Successfully joined coordination session"
        
        # Start heartbeat
        start_heartbeat
        
        return 0
    else
        error "Failed to join coordination session"
        return 1
    fi
}

# Process coordination request
process_coordination_request() {
    local message="$1"
    local coordination_id=$(echo "$message" | jq -r '.coordination_id')
    local operation_type=$(echo "$message" | jq -r '.operation_type')
    local coordinator=$(echo "$message" | jq -r '.coordinator')
    
    log "Received coordination request for operation: $operation_type"
    
    # Validate readiness for operation
    if validate_vm_readiness "$operation_type"; then
        # Auto-join if VM is ready
        COORDINATION_ID="$coordination_id"
        OPERATION_TYPE="$operation_type"
        join_coordination
    else
        warn "VM not ready for operation: $operation_type"
    fi
}

# Validate VM readiness
# Validate readiness (VM or container mode)
validate_vm_readiness() {
    local operation="$1"
    
    if [[ "$DEPLOYMENT_MODE" == "container" ]]; then
        validate_container_readiness "$operation"
    else
        validate_multi_vm_readiness "$operation"
    fi
}

# Validate container readiness (single VM mode)
validate_container_readiness() {
    local operation="$1"
    
    log "Validating container readiness for operation: $operation"
    
    # Check system resources
    local available_memory=$(free -m | awk '/^Mem:/ {print $7}')
    local available_disk=$(df / | awk 'NR==2 {print $4}')
    
    if [[ "$available_memory" -lt 512 ]]; then
        warn "Insufficient memory: ${available_memory}MB"
        return 1
    fi
    
    if [[ "$available_disk" -lt 1048576 ]]; then  # 1GB
        warn "Insufficient disk space"
        return 1
    fi
    
    # Check container runtime
    if ! $CONTAINER_RUNTIME info &>/dev/null; then
        warn "Container runtime ($CONTAINER_RUNTIME) not available"
        return 1
    fi
    
    # Check Jenkins containers
    for container in "${CONTAINERS[@]}"; do
        if $CONTAINER_RUNTIME inspect "$container" &>/dev/null; then
            local status=$($CONTAINER_RUNTIME inspect "$container" --format='{{.State.Status}}')
            if [[ "$status" != "running" ]]; then
                warn "Container $container is not running (status: $status)"
            else
                info "Container $container is healthy"
            fi
        else
            warn "Container $container not found"
        fi
    done
    
    # Check shared storage
    if ! findmnt /var/jenkins_home &>/dev/null; then
        warn "Shared storage not mounted at /var/jenkins_home"
        return 1
    fi
    
    success "Container readiness validation passed"
    return 0
}

# Validate multi-VM readiness (distributed mode)
validate_multi_vm_readiness() {
    local operation="$1"
    
    log "Validating VM readiness for operation: $operation"
    
    # Check system resources
    local available_memory=$(free -m | awk '/^Mem:/ {print $7}')
    local available_disk=$(df / | awk 'NR==2 {print $4}')
    
    if [[ "$available_memory" -lt 512 ]]; then
        warn "Insufficient memory: ${available_memory}MB"
        return 1
    fi
    
    if [[ "$available_disk" -lt 1048576 ]]; then  # 1GB
        warn "Insufficient disk space"
        return 1
    fi
    
    # Check container runtime
    if ! $CONTAINER_RUNTIME info &>/dev/null; then
        warn "Container runtime not available"
        return 1
    fi
    
    # Check Jenkins containers
    if [[ "$operation" == "upgrade" ]]; then
        local container_name="jenkins-${TEAM_NAME}-${TARGET_ENVIRONMENT:-blue}"
        if ! $CONTAINER_RUNTIME inspect "$container_name" &>/dev/null; then
            warn "Target Jenkins container not found: $container_name"
            return 1
        fi
    fi
    
    # Check network connectivity to other VMs
    if [[ ${#VMS[@]} -gt 1 ]]; then
        for vm in "${VMS[@]}"; do
            if [[ "$vm" != "$LOCAL_VM" ]]; then
                if ! ping -c 1 -W 5 "$vm" &>/dev/null; then
                    warn "Network connectivity issues to $vm"
                    return 1
                fi
            fi
        done
    fi
    
    success "Multi-VM readiness validation passed"
    return 0
}

# Request votes from all VMs
request_votes() {
    log "Requesting votes for operation: $OPERATION_TYPE"
    
    local vote_request=$(cat <<EOF
{
    "type": "vote_request",
    "coordination_id": "$COORDINATION_ID",
    "operation_type": "$OPERATION_TYPE",
    "team": "$TEAM_NAME",
    "environment": "${TARGET_ENVIRONMENT:-}",
    "voting_deadline": "$(date -u -d "+${CONSENSUS_TIMEOUT} seconds" +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
)
    
    if broadcast_message "$vote_request"; then
        log "Vote request sent to all VMs"
        
        # Wait for votes
        wait_for_consensus
        
        return $?
    else
        error "Failed to send vote request"
        return 1
    fi
}

# Process vote request
process_vote_request() {
    local message="$1"
    local coordination_id=$(echo "$message" | jq -r '.coordination_id')
    
    log "Processing vote request for coordination: $coordination_id"
    
    # Perform local validation
    local vote="approve"
    if ! validate_vm_readiness "$OPERATION_TYPE"; then
        vote="reject"
    fi
    
    # Send vote response
    local vote_response=$(cat <<EOF
{
    "type": "vote_response",
    "coordination_id": "$coordination_id",
    "vm": "$LOCAL_VM",
    "vote": "$vote",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "reason": "${vote == 'reject' ? 'VM not ready' : 'VM ready'}"
}
EOF
)
    
    local coordinator="${VMS[0]}"
    send_coordination_message "$coordinator" "$vote_response"
}

# Wait for consensus (VM or container mode)
wait_for_consensus() {
    log "Waiting for consensus (timeout: ${CONSENSUS_TIMEOUT}s)..."
    
    local start_time=$(date +%s)
    local votes_file="$COORDINATOR_STATE_DIR/votes-${COORDINATION_ID}.json"
    
    # Initialize votes tracking
    echo '{}' > "$votes_file"
    
    if [[ "$DEPLOYMENT_MODE" == "container" ]]; then
        # Container mode: simplified consensus (single host decision)
        log "Container mode: performing local validation for consensus..."
        
        if validate_container_readiness "$OPERATION_TYPE"; then
            # Add local approval vote
            jq --arg vm "$LOCAL_VM" --arg vote "approve" --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                '.[$vm] = {"vote": $vote, "timestamp": $timestamp, "reason": "Container validation passed"}' \
                "$votes_file" > "$votes_file.tmp" && mv "$votes_file.tmp" "$votes_file"
            
            success "Consensus reached: APPROVED (container mode)"
            CONSENSUS_REACHED=true
            return 0
        else
            # Add local rejection vote
            jq --arg vm "$LOCAL_VM" --arg vote "reject" --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                '.[$vm] = {"vote": $vote, "timestamp": $timestamp, "reason": "Container validation failed"}' \
                "$votes_file" > "$votes_file.tmp" && mv "$votes_file.tmp" "$votes_file"
            
            error "Consensus reached: REJECTED (container mode)"
            return 1
        fi
    fi
    
    # Multi-VM mode: wait for distributed consensus
    while true; do
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        
        if [[ "$elapsed" -gt "$CONSENSUS_TIMEOUT" ]]; then
            error "Consensus timeout reached"
            return 1
        fi
        
        # Check for new votes
        local total_votes=$(jq 'length' "$votes_file")
        local approve_votes=$(jq '[.[] | select(.vote == "approve")] | length' "$votes_file")
        local reject_votes=$(jq '[.[] | select(.vote == "reject")] | length' "$votes_file")
        
        local quorum_size=$(jq '.quorum_size' "$COORDINATOR_STATE_DIR/vm-inventory.json")
        
        info "Vote status: ${approve_votes} approve, ${reject_votes} reject (${total_votes}/${#VMS[@]} total)"
        
        # Check for consensus
        if [[ "$approve_votes" -ge "$quorum_size" ]]; then
            success "Consensus reached: APPROVED"
            CONSENSUS_REACHED=true
            return 0
        elif [[ "$reject_votes" -ge "$quorum_size" ]]; then
            error "Consensus reached: REJECTED"
            return 1
        elif [[ "$total_votes" -eq "${#VMS[@]}" ]]; then
            if [[ "$approve_votes" -gt "$reject_votes" ]]; then
                if [[ "${FORCE_OPERATION:-false}" == "true" ]]; then
                    warn "Forcing operation with majority approval"
                    CONSENSUS_REACHED=true
                    return 0
                else
                    error "No consensus reached, but majority approves. Use --force to proceed"
                    return 1
                fi
            else
                error "No consensus reached: majority rejects"
                return 1
            fi
        fi
        
        sleep 5
    done
}

# Execute coordinated operation
execute_coordinated_operation() {
    if [[ "$CONSENSUS_REACHED" != "true" ]]; then
        error "Cannot execute operation without consensus"
        return 1
    fi
    
    log "Executing coordinated operation: $OPERATION_TYPE"
    
    # Broadcast execution command
    local execution_command=$(cat <<EOF
{
    "type": "execution_command",
    "coordination_id": "$COORDINATION_ID",
    "operation_type": "$OPERATION_TYPE",
    "team": "$TEAM_NAME",
    "environment": "${TARGET_ENVIRONMENT:-}",
    "upgrade_type": "${UPGRADE_TYPE:-}",
    "execute_at": "$(date -u -d "+30 seconds" +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
)
    
    if broadcast_message "$execution_command"; then
        success "Execution command broadcast successfully"
        
        # Execute locally
        sleep 30
        execute_local_operation
        
        return $?
    else
        error "Failed to broadcast execution command"
        return 1
    fi
}

# Execute local operation
execute_local_operation() {
    log "Executing local operation: $OPERATION_TYPE"
    
    case "$OPERATION_TYPE" in
        "upgrade")
            execute_upgrade_operation
            ;;
        "switch")
            execute_switch_operation
            ;;
        "rollback")
            execute_rollback_operation
            ;;
        "maintenance")
            execute_maintenance_operation
            ;;
        *)
            error "Unknown operation type: $OPERATION_TYPE"
            return 1
            ;;
    esac
}

# Execute upgrade operation (VM or container mode)
execute_upgrade_operation() {
    log "Executing upgrade operation for team: $TEAM_NAME"
    
    # Run the universal upgrade validator
    local validator_flags=""
    if [[ "$DEPLOYMENT_MODE" == "container" ]]; then
        validator_flags="--container-mode"
    else
        validator_flags="--multi-vm"
    fi
    
    if ! "$JENKINS_HOME/scripts/universal-upgrade-validator.sh" \
         --type "${UPGRADE_TYPE}" \
         --team "$TEAM_NAME" \
         --environment "${TARGET_ENVIRONMENT}" \
         $validator_flags; then
        error "Upgrade validation failed"
        return 1
    fi
    
    # Container mode: use container-specific upgrade commands
    if [[ "$DEPLOYMENT_MODE" == "container" ]]; then
        execute_container_upgrade
        return $?
    fi
    
    # Multi-VM mode: use Ansible playbooks
    case "$UPGRADE_TYPE" in
        "jenkins_version")
            ansible-playbook -i "{{ ansible_inventory_sources[0] }}" \
                "{{ ansible_playbook_dir }}/upgrade-handlers/jenkins_version-upgrade.yml" \
                -e "target_version=${TARGET_VERSION}" \
                -e "upgrade_env=${TARGET_ENVIRONMENT}" \
                -e "team_list=[\"$TEAM_NAME\"]"
            ;;
        "plugins")
            ansible-playbook -i "{{ ansible_inventory_sources[0] }}" \
                "{{ ansible_playbook_dir }}/upgrade-handlers/plugins-upgrade.yml" \
                -e "plugins_to_upgrade=${PLUGINS_LIST}" \
                -e "upgrade_env=${TARGET_ENVIRONMENT}" \
                -e "team_list=[\"$TEAM_NAME\"]"
            ;;
        "job_dsl")
            ansible-playbook -i "{{ ansible_inventory_sources[0] }}" \
                "{{ ansible_playbook_dir }}/upgrade-handlers/job_dsl-upgrade.yml" \
                -e "dsl_source=${DSL_SOURCE}" \
                -e "upgrade_env=${TARGET_ENVIRONMENT}" \
                -e "team_list=[\"$TEAM_NAME\"]"
            ;;
        "infrastructure")
            ansible-playbook -i "{{ ansible_inventory_sources[0] }}" \
                "{{ ansible_playbook_dir }}/upgrade-handlers/infrastructure-upgrade.yml" \
                -e "infrastructure_changes=${INFRASTRUCTURE_CHANGES}" \
                -e "upgrade_env=${TARGET_ENVIRONMENT}" \
                -e "team_list=[\"$TEAM_NAME\"]"
            ;;
    esac
}

# Execute container-specific upgrade
execute_container_upgrade() {
    log "Executing container-mode upgrade for team: $TEAM_NAME"
    
    local target_container="jenkins-${TEAM_NAME}-${TARGET_ENVIRONMENT:-green}"
    local source_container="jenkins-${TEAM_NAME}-${SOURCE_ENVIRONMENT:-blue}"
    
    case "$UPGRADE_TYPE" in
        "jenkins_version")
            log "Upgrading Jenkins version in container: $target_container"
            
            # Stop target container
            $CONTAINER_RUNTIME stop "$target_container" 2>/dev/null || true
            $CONTAINER_RUNTIME rm "$target_container" 2>/dev/null || true
            
            # Build new image with target version
            $CONTAINER_RUNTIME build -t "jenkins-${TEAM_NAME}:${TARGET_VERSION}" \
                --build-arg JENKINS_VERSION="${TARGET_VERSION}" \
                "$JENKINS_HOME/docker-images/jenkins-master/"
            
            # Start new container
            $CONTAINER_RUNTIME run -d \
                --name "$target_container" \
                --network jenkins-network \
                -v jenkins_home:/var/jenkins_home \
                -p "${TARGET_PORT}:8080" \
                "jenkins-${TEAM_NAME}:${TARGET_VERSION}"
            ;;
            
        "plugins")
            log "Upgrading plugins in container: $target_container"
            
            # Use plugin management script
            $CONTAINER_RUNTIME exec "$target_container" \
                /var/jenkins_home/scripts/plugin-downloader.sh \
                --plugins "${PLUGINS_LIST}" \
                --update
            
            # Restart container to load new plugins
            $CONTAINER_RUNTIME restart "$target_container"
            ;;
            
        "job_dsl")
            log "Updating Job DSL configuration in container: $target_container"
            
            # Update DSL configuration
            $CONTAINER_RUNTIME exec "$target_container" \
                /var/jenkins_home/scripts/dsl-syntax-validator.sh \
                --source "${DSL_SOURCE}" \
                --apply
            ;;
            
        "infrastructure")
            log "Applying infrastructure changes to container: $target_container"
            
            # Apply infrastructure configuration
            $CONTAINER_RUNTIME exec "$target_container" \
                /var/jenkins_home/scripts/infrastructure-updater.sh \
                --changes "${INFRASTRUCTURE_CHANGES}"
            ;;
    esac
    
    # Validate container health after upgrade
    if validate_container_health "$target_container"; then
        success "Container upgrade completed successfully"
        return 0
    else
        error "Container upgrade validation failed"
        return 1
    fi
}

# Validate container health
validate_container_health() {
    local container_name="$1"
    local max_attempts=30
    local attempt=0
    
    log "Validating health of container: $container_name"
    
    while [[ $attempt -lt $max_attempts ]]; do
        if $CONTAINER_RUNTIME inspect "$container_name" --format='{{.State.Status}}' | grep -q "running"; then
            # Check if Jenkins is responding
            local container_port=$($CONTAINER_RUNTIME port "$container_name" 8080 | cut -d: -f2)
            if curl -sf "http://localhost:${container_port}/login" >/dev/null 2>&1; then
                success "Container $container_name is healthy"
                return 0
            fi
        fi
        
        ((attempt++))
        log "Health check attempt $attempt/$max_attempts for $container_name"
        sleep 10
    done
    
    error "Container $container_name failed health validation"
    return 1
}

# Execute switch operation (VM or container mode)
execute_switch_operation() {
    log "Executing environment switch operation"
    
    if [[ "$DEPLOYMENT_MODE" == "container" ]]; then
        execute_container_switch
    else
        # Use canary traffic controller for gradual switch
        "$JENKINS_HOME/scripts/canary-traffic-controller.sh" \
            --team "$TEAM_NAME" \
            --source-env "${SOURCE_ENVIRONMENT:-blue}" \
            --target-env "$TARGET_ENVIRONMENT" \
            --traffic-percent 100 \
            --auto-rollback
    fi
}

# Execute container-specific switch operation
execute_container_switch() {
    log "Executing container-mode environment switch for team: $TEAM_NAME"
    
    local source_container="jenkins-${TEAM_NAME}-${SOURCE_ENVIRONMENT:-blue}"
    local target_container="jenkins-${TEAM_NAME}-${TARGET_ENVIRONMENT:-green}"
    
    # Validate target container is ready
    if ! validate_container_health "$target_container"; then
        error "Target container $target_container is not healthy, aborting switch"
        return 1
    fi
    
    # Update HAProxy configuration for container switch
    log "Updating HAProxy configuration for container switch..."
    
    # Create HAProxy backend configuration update
    cat > /tmp/haproxy-backend-update.cfg <<EOF
backend jenkins_${TEAM_NAME}_backend
    balance roundrobin
    option httpchk GET /login
    server ${target_container} ${target_container}:8080 check
    server ${source_container} ${source_container}:8080 check backup
EOF
    
    # Apply HAProxy configuration
    if docker exec haproxy-container cat /tmp/haproxy-backend-update.cfg >> /etc/haproxy/haproxy.cfg; then
        docker exec haproxy-container haproxy -f /etc/haproxy/haproxy.cfg -c
        if [[ $? -eq 0 ]]; then
            docker exec haproxy-container systemctl reload haproxy
            success "HAProxy configuration updated for container switch"
        else
            error "HAProxy configuration validation failed"
            return 1
        fi
    else
        error "Failed to update HAProxy configuration"
        return 1
    fi
    
    # Verify switch success
    sleep 30
    if validate_container_health "$target_container"; then
        success "Container environment switch completed successfully"
        
        # Mark old container as backup
        log "Marking source container $source_container as backup"
        return 0
    else
        error "Container switch validation failed"
        return 1
    fi
}

# Execute rollback operation
execute_rollback_operation() {
    log "Executing rollback operation"
    
    # Switch traffic back to previous environment
    "$JENKINS_HOME/scripts/canary-traffic-controller.sh" \
        --team "$TEAM_NAME" \
        --source-env "$TARGET_ENVIRONMENT" \
        --target-env "${SOURCE_ENVIRONMENT:-blue}" \
        --traffic-percent 100
}

# Execute maintenance operation
execute_maintenance_operation() {
    log "Executing maintenance operation"
    
    # Perform maintenance tasks (cleanup, optimization, etc.)
    case "${MAINTENANCE_TYPE:-general}" in
        "cleanup")
            docker system prune -f
            ;;
        "backup")
            "$JENKINS_HOME/scripts/backup.sh" --team "$TEAM_NAME"
            ;;
        "health-check")
            "$JENKINS_HOME/scripts/jenkins-health-checker.sh" --team "$TEAM_NAME"
            ;;
        *)
            info "General maintenance operation completed"
            ;;
    esac
}

# Start heartbeat monitoring
start_heartbeat_monitor() {
    log "Starting heartbeat monitoring for coordination session"
    
    (
        while [[ -f "$COORDINATOR_STATE_DIR/session-${COORDINATION_ID}.json" ]]; do
            sleep "$HEARTBEAT_INTERVAL"
            
            # Check VM health and send heartbeat
            local heartbeat=$(cat <<EOF
{
    "type": "heartbeat",
    "coordination_id": "$COORDINATION_ID",
    "vm": "$LOCAL_VM",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "status": "alive"
}
EOF
)
            
            broadcast_message "$heartbeat" &>/dev/null || true
        done
    ) &
    
    echo $! > "$COORDINATOR_STATE_DIR/heartbeat-${COORDINATION_ID}.pid"
}

# Start heartbeat
start_heartbeat() {
    log "Starting heartbeat for coordination session"
    
    (
        local coordinator="${VMS[0]}"
        
        while [[ -f "$COORDINATOR_STATE_DIR/session-${COORDINATION_ID}.json" ]]; do
            sleep "$HEARTBEAT_INTERVAL"
            
            local heartbeat=$(cat <<EOF
{
    "type": "heartbeat",
    "coordination_id": "$COORDINATION_ID",
    "vm": "$LOCAL_VM",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "status": "alive"
}
EOF
)
            
            send_coordination_message "$coordinator" "$heartbeat" &>/dev/null || true
        done
    ) &
    
    echo $! > "$COORDINATOR_STATE_DIR/heartbeat-${COORDINATION_ID}.pid"
}

# Process heartbeat
process_heartbeat() {
    local message="$1"
    local vm=$(echo "$message" | jq -r '.vm')
    local timestamp=$(echo "$message" | jq -r '.timestamp')
    
    # Update VM status
    local status_file="$COORDINATOR_STATE_DIR/vm-status.json"
    
    if [[ ! -f "$status_file" ]]; then
        echo '{}' > "$status_file"
    fi
    
    jq --arg vm "$vm" --arg timestamp "$timestamp" \
        '.[$vm] = {"last_heartbeat": $timestamp, "status": "alive"}' \
        "$status_file" > "$status_file.tmp" && mv "$status_file.tmp" "$status_file"
}

# Show coordination status
show_coordination_status() {
    if [[ -n "$COORDINATION_ID" && -f "$COORDINATOR_STATE_DIR/session-${COORDINATION_ID}.json" ]]; then
        log "Coordination Status for session: $COORDINATION_ID"
        jq . "$COORDINATOR_STATE_DIR/session-${COORDINATION_ID}.json"
        
        if [[ -f "$COORDINATOR_STATE_DIR/vm-status.json" ]]; then
            echo
            log "VM Status:"
            jq . "$COORDINATOR_STATE_DIR/vm-status.json"
        fi
    else
        info "No active coordination session found"
    fi
}

# Cleanup coordination state
cleanup_coordination_state() {
    log "Cleaning up coordination state..."
    
    if [[ -n "$COORDINATION_ID" ]]; then
        # Stop heartbeat
        if [[ -f "$COORDINATOR_STATE_DIR/heartbeat-${COORDINATION_ID}.pid" ]]; then
            local heartbeat_pid=$(cat "$COORDINATOR_STATE_DIR/heartbeat-${COORDINATION_ID}.pid")
            kill "$heartbeat_pid" 2>/dev/null || true
            rm -f "$COORDINATOR_STATE_DIR/heartbeat-${COORDINATION_ID}.pid"
        fi
        
        # Remove session files
        rm -f "$COORDINATOR_STATE_DIR/session-${COORDINATION_ID}.json"
        rm -f "$COORDINATOR_STATE_DIR/votes-${COORDINATION_ID}.json"
    fi
    
    # Clean old sessions (older than 24 hours)
    find "$COORDINATOR_STATE_DIR" -name "session-*.json" -mtime +1 -delete 2>/dev/null || true
    find "$COORDINATOR_STATE_DIR" -name "votes-*.json" -mtime +1 -delete 2>/dev/null || true
    
    success "Coordination state cleanup completed"
}

# Main execution function
main() {
    parse_args "$@"
    
    # Initialize coordination state
    init_coordination_state
    
    # Handle special commands
    if [[ "${SHOW_STATUS:-false}" == "true" ]]; then
        show_coordination_status
        return 0
    fi
    
    if [[ "${CLEANUP_STATE:-false}" == "true" ]]; then
        cleanup_coordination_state
        return 0
    fi
    
    # Handle coordination commands
    case "${COMMAND:-}" in
        "initiate")
            if [[ -z "$COORDINATION_ID" ]]; then
                COORDINATION_ID="${OPERATION_TYPE}-$(date +%s)"
            fi
            initiate_coordination
            ;;
        "join")
            join_coordination
            ;;
        "vote")
            request_votes
            ;;
        "consensus")
            if [[ "$IS_COORDINATOR" == "true" ]]; then
                wait_for_consensus
            else
                error "Only coordinator can check consensus"
                return 1
            fi
            ;;
        "execute")
            execute_coordinated_operation
            ;;
        "abort")
            cleanup_coordination_state
            ;;
        *)
            if [[ -n "$OPERATION_TYPE" ]]; then
                # Auto-flow: initiate -> vote -> execute
                if [[ "$IS_COORDINATOR" == "true" ]]; then
                    if [[ -z "$COORDINATION_ID" ]]; then
                        COORDINATION_ID="${OPERATION_TYPE}-$(date +%s)"
                    fi
                    
                    log "Starting coordinated operation: $OPERATION_TYPE"
                    
                    initiate_coordination && \
                    request_votes && \
                    execute_coordinated_operation
                else
                    log "Waiting for coordination from coordinator VM"
                    # Participant mode - wait for coordination requests
                    while true; do
                        sleep 10
                        if [[ -f "$COORDINATOR_STATE_DIR/session-${COORDINATION_ID:-unknown}.json" ]]; then
                            break
                        fi
                    done
                fi
            else
                error "Operation type is required"
                usage
                return 1
            fi
            ;;
    esac
}

# Handle script termination
trap 'cleanup_coordination_state; exit 130' INT TERM

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi