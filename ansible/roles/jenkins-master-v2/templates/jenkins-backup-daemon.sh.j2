#!/bin/bash
# Jenkins Backup Daemon for {{ item.team_name }}
# Dedicated background backup script for Jenkins data protection
# Generated by Ansible jenkins-master-v2 role

set -euo pipefail

# Script configuration
TEAM_NAME="{{ item.team_name }}"
ACTIVE_ENV="{{ item.active_environment | default('blue') }}"
CONTAINER_NAME="jenkins-${TEAM_NAME}-${ACTIVE_ENV}"
STORAGE_PATH="{{ storage_path }}"
TEAM_STORAGE_PATH="${STORAGE_PATH}/${TEAM_NAME}"

# Backup configuration
BACKUP_METHOD="{{ backup_method | default('tar') }}"
BACKUP_LOCAL_DIR="{{ backup_local_dir | default('/var/backups/jenkins') }}"
BACKUP_RETENTION_DAYS="{{ backup_daily_retention | default(7) }}"
BACKUP_COMPRESSION="{{ backup_compression | default('gzip') }}"
BACKUP_VERIFICATION_ENABLED="{{ backup_verification_enabled | default(true) }}"

# Daemon configuration
DAEMON_MODE=false
DAEMON_INTERVAL="{{ backup_daemon_interval | default(3600) }}"
PID_FILE="/var/run/jenkins-backup-${TEAM_NAME}.pid"
LOG_FILE="/var/log/jenkins-${TEAM_NAME}-backup.log"
VERBOSE=false
DRY_RUN=false

# Data types to backup
DATA_TYPES=("jobs" "workspace" "builds" "userContent" "secrets")

# Logging functions
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] $*" | tee -a "$LOG_FILE"
}

warn() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [WARN] $*" | tee -a "$LOG_FILE"
}

error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] $*" | tee -a "$LOG_FILE"
}

debug() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [DEBUG] $*" | tee -a "$LOG_FILE"
    fi
}

# Usage function
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Jenkins Backup Daemon for ${TEAM_NAME}

DAEMON OPTIONS:
    --daemon                 Run in daemon mode (continuous background operation)
    --interval <seconds>     Backup interval in seconds (default: ${DAEMON_INTERVAL})
    --stop                   Stop running daemon

BACKUP OPTIONS:
    --backup-method {tar|borg}    Backup method (default: ${BACKUP_METHOD})
    --retention <days>            Backup retention in days (default: ${BACKUP_RETENTION_DAYS})
    --backup-dir <path>           Backup directory (default: ${BACKUP_LOCAL_DIR})

GENERAL OPTIONS:
    --dry-run                Show what would be done without executing
    --verbose                Enable verbose logging
    --verify                 Enable backup verification (default: enabled)
    --no-verify              Disable backup verification
    --help                   Show this help message

EXAMPLES:
    $0                           # Single backup run
    $0 --daemon                  # Start daemon mode
    $0 --daemon --interval 1800  # Start daemon with 30-minute intervals
    $0 --stop                    # Stop running daemon
    $0 --dry-run --verbose       # Preview backup operations

DAEMON FEATURES:
    • Continuous background operation
    • Automatic container detection and switching
    • Health monitoring and recovery
    • Backup verification and integrity checks
    • Automatic cleanup of old backups
    • Signal handling for graceful shutdown

EOF
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --daemon)
                DAEMON_MODE=true
                shift
                ;;
            --interval)
                DAEMON_INTERVAL="$2"
                shift 2
                ;;
            --stop)
                stop_daemon
                exit 0
                ;;
            --backup-method)
                BACKUP_METHOD="$2"
                shift 2
                ;;
            --retention)
                BACKUP_RETENTION_DAYS="$2"
                shift 2
                ;;
            --backup-dir)
                BACKUP_LOCAL_DIR="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --verify)
                BACKUP_VERIFICATION_ENABLED=true
                shift
                ;;
            --no-verify)
                BACKUP_VERIFICATION_ENABLED=false
                shift
                ;;
            --help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
}

# Validate configuration
validate_configuration() {
    debug "Validating backup configuration..."
    
    # Validate backup method
    if [[ "$BACKUP_METHOD" != "tar" && "$BACKUP_METHOD" != "borg" ]]; then
        error "Invalid backup method: $BACKUP_METHOD. Must be 'tar' or 'borg'"
        return 1
    fi
    
    # Validate retention period
    if [[ ! "$BACKUP_RETENTION_DAYS" =~ ^[0-9]+$ ]] || [[ "$BACKUP_RETENTION_DAYS" -lt 1 ]]; then
        error "Invalid retention period: $BACKUP_RETENTION_DAYS. Must be a positive number"
        return 1
    fi
    
    # Validate daemon interval
    if [[ ! "$DAEMON_INTERVAL" =~ ^[0-9]+$ ]] || [[ "$DAEMON_INTERVAL" -lt 60 ]]; then
        error "Invalid daemon interval: $DAEMON_INTERVAL. Must be at least 60 seconds"
        return 1
    fi
    
    debug "Configuration validation passed"
    return 0
}

# Check prerequisites
check_prerequisites() {
    debug "Checking backup prerequisites..."
    
    local prerequisites_ok=true
    
    # Check backup directory accessibility
    local backup_dir="${BACKUP_LOCAL_DIR}/${TEAM_NAME}"
    if [[ ! -d "$backup_dir" ]]; then
        debug "Creating backup directory: $backup_dir"
        if [[ "$DRY_RUN" != "true" ]]; then
            mkdir -p "$backup_dir" || {
                error "Failed to create backup directory: $backup_dir"
                prerequisites_ok=false
            }
        fi
    elif [[ ! -w "$backup_dir" ]]; then
        error "Backup directory not writable: $backup_dir"
        prerequisites_ok=false
    fi
    
    # Check available disk space
    local available_space
    available_space=$(df "$backup_dir" | awk 'NR==2 {print $4}')
    local min_space_kb=$((1024 * 1024))
    
    if [[ "$available_space" -lt "$min_space_kb" ]]; then
        error "Insufficient disk space for backup. Available: $(($available_space/1024))MB, Required: 1GB"
        prerequisites_ok=false
    fi
    
    if [[ "$prerequisites_ok" != "true" ]]; then
        error "Prerequisites check failed"
        return 1
    fi
    
    debug "Prerequisites check passed"
    return 0
}

# Get current active container
get_active_container() {
    # Dynamic container detection based on current active environment
    local current_active_env
    current_active_env=$(docker ps --filter "name=jenkins-${TEAM_NAME}-" --format "{{ '{{' }}.Names{{ '}}' }}" | grep -E "jenkins-${TEAM_NAME}-(blue|green)$" | head -1)
    
    if [[ -n "$current_active_env" ]]; then
        echo "$current_active_env"
    else
        # Fallback to configured active environment
        echo "jenkins-${TEAM_NAME}-${ACTIVE_ENV}"
    fi
}

# Check if container is running and accessible
check_container_availability() {
    local container_name="$1"
    
    if ! docker ps --filter "name=${container_name}" | grep -q "${container_name}"; then
        debug "Container ${container_name} not running"
        return 1
    fi
    
    # Quick health check
    if ! docker exec "${container_name}" test -d "/var/jenkins_home" 2>/dev/null; then
        debug "Container ${container_name} not accessible"
        return 1
    fi
    
    return 0
}

# Perform backup operation
perform_backup() {
    log "[BACKUP] Starting backup operation for ${TEAM_NAME}..."
    
    # Get current active container
    local current_container
    current_container=$(get_active_container)
    
    if ! check_container_availability "$current_container"; then
        warn "Active container not available, skipping backup cycle"
        return 1
    fi
    
    local backup_dir="${BACKUP_LOCAL_DIR}/${TEAM_NAME}"
    local timestamp=$(date '+%Y%m%d_%H%M%S')
    local backup_name="${TEAM_NAME}_backup_${timestamp}"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "[DRY RUN] Would create backup: ${backup_dir}/${backup_name}"
        return 0
    fi
    
    mkdir -p "$backup_dir"
    
    case "$BACKUP_METHOD" in
        "tar")
            perform_tar_backup "$backup_dir" "$backup_name" "$current_container"
            ;;
        "borg")
            perform_borg_backup "$backup_dir" "$backup_name" "$current_container"
            ;;
        *)
            error "Unknown backup method: $BACKUP_METHOD"
            return 1
            ;;
    esac
}

# Perform tar backup
perform_tar_backup() {
    local backup_dir="$1"
    local backup_name="$2"
    local container_name="$3"
    local backup_file="${backup_dir}/${backup_name}.tar"
    
    debug "Creating tar backup from container: $container_name"
    
    # Add compression if enabled
    if [[ "$BACKUP_COMPRESSION" == "gzip" ]]; then
        backup_file="${backup_file}.gz"
        local tar_options="czf"
    else
        local tar_options="cf"
    fi
    
    # Create temporary directory for container data extraction
    local temp_dir="/tmp/jenkins-backup-${TEAM_NAME}-$$"
    mkdir -p "$temp_dir"
    
    local backup_success=0
    local backup_total=${{ '{#' }}DATA_TYPES[@]}
    
    # Extract data from container
    for data_type in "${DATA_TYPES[@]}"; do
        local container_path="/var/jenkins_home/${data_type}"
        local temp_path="${temp_dir}/${data_type}"
        
        if docker exec "${container_name}" test -d "${container_path}" 2>/dev/null; then
            debug "Backing up ${data_type} from ${container_name}..."
            if docker cp "${container_name}:${container_path}" "$temp_path"; then
                ((backup_success++))
            else
                error "Failed to extract ${data_type} from container ${container_name}"
            fi
        else
            debug "Skipping missing ${data_type} in ${container_name}"
            ((backup_success++))
        fi
    done
    
    # Create tar archive
    if [[ $backup_success -eq $backup_total ]]; then
        if tar $tar_options "$backup_file" -C "$temp_dir" .; then
            log "[SUCCESS] Backup created successfully: $backup_file"
            
            # Verify backup if enabled
            if [[ "$BACKUP_VERIFICATION_ENABLED" == "true" ]]; then
                verify_tar_backup "$backup_file"
            fi
            
            # Set proper ownership
            chown {{ jenkins_user }}:{{ jenkins_group }} "$backup_file"
            
            # Cleanup old backups
            cleanup_old_backups "$backup_dir"
            
            # Cleanup temporary directory
            rm -rf "$temp_dir"
            
            return 0
        else
            error "Failed to create tar backup"
            rm -rf "$temp_dir"
            return 1
        fi
    else
        error "Failed to extract all data types for backup"
        rm -rf "$temp_dir"
        return 1
    fi
}

# Perform borg backup (placeholder)
perform_borg_backup() {
    local backup_dir="$1"
    local backup_name="$2"
    local container_name="$3"
    
    # Borg backup implementation would go here
    # This is a placeholder for future borg integration
    warn "Borg backup not yet implemented, falling back to tar"
    perform_tar_backup "$backup_dir" "$backup_name" "$container_name"
}

# Verify tar backup
verify_tar_backup() {
    local backup_file="$1"
    
    debug "Verifying backup integrity: $backup_file"
    
    if [[ "$backup_file" == *.gz ]]; then
        if tar -tzf "$backup_file" >/dev/null 2>&1; then
            debug "[SUCCESS] Backup verification passed"
            return 0
        else
            error "[ERROR] Backup verification failed"
            return 1
        fi
    else
        if tar -tf "$backup_file" >/dev/null 2>&1; then
            debug "[SUCCESS] Backup verification passed"
            return 0
        else
            error "[ERROR] Backup verification failed"
            return 1
        fi
    fi
}

# Cleanup old backups
cleanup_old_backups() {
    local backup_dir="$1"
    
    debug "Cleaning up old backups (retention: ${BACKUP_RETENTION_DAYS} days)"
    
    # Find and remove backups older than retention period
    find "$backup_dir" -name "${TEAM_NAME}_backup_*.tar*" -type f -mtime +${BACKUP_RETENTION_DAYS} -delete || true
    
    local remaining_backups
    remaining_backups=$(find "$backup_dir" -name "${TEAM_NAME}_backup_*.tar*" -type f | wc -l)
    debug "Remaining backups: $remaining_backups"
}

# Daemon management functions
start_daemon() {
    if [[ -f "$PID_FILE" ]]; then
        local existing_pid
        existing_pid=$(cat "$PID_FILE")
        if kill -0 "$existing_pid" 2>/dev/null; then
            error "Daemon already running with PID: $existing_pid"
            exit 1
        else
            warn "Removing stale PID file: $PID_FILE"
            rm -f "$PID_FILE"
        fi
    fi
    
    log "[DAEMON] Starting backup daemon for ${TEAM_NAME}"
    log "[DAEMON] Backup interval: ${DAEMON_INTERVAL} seconds"
    log "[DAEMON] PID file: $PID_FILE"
    
    # Store PID
    echo $$ > "$PID_FILE"
    
    # Setup signal handlers
    trap 'daemon_shutdown' SIGTERM SIGINT
    
    # Main daemon loop
    while true; do
        debug "[DAEMON] Starting backup cycle"
        
        if perform_backup; then
            log "[DAEMON] Backup cycle completed successfully"
        else
            warn "[DAEMON] Backup cycle completed with errors"
        fi
        
        debug "[DAEMON] Sleeping for ${DAEMON_INTERVAL} seconds"
        sleep "$DAEMON_INTERVAL" &
        wait $!  # Interruptible sleep
    done
}

stop_daemon() {
    if [[ ! -f "$PID_FILE" ]]; then
        log "No daemon PID file found"
        return 0
    fi
    
    local pid
    pid=$(cat "$PID_FILE")
    
    if kill -0 "$pid" 2>/dev/null; then
        log "Stopping daemon with PID: $pid"
        kill -TERM "$pid"
        
        # Wait for graceful shutdown
        local count=0
        while kill -0 "$pid" 2>/dev/null && [[ $count -lt 10 ]]; do
            sleep 1
            ((count++))
        done
        
        if kill -0 "$pid" 2>/dev/null; then
            warn "Force killing daemon with PID: $pid"
            kill -KILL "$pid"
        fi
        
        rm -f "$PID_FILE"
        log "Daemon stopped successfully"
    else
        log "Daemon not running (PID: $pid)"
        rm -f "$PID_FILE"
    fi
}

daemon_shutdown() {
    log "[DAEMON] Received shutdown signal, stopping gracefully"
    rm -f "$PID_FILE"
    exit 0
}

# Main execution function
main() {
    log "[START] Jenkins backup daemon for ${TEAM_NAME}"
    
    # Parse arguments and validate configuration
    parse_arguments "$@"
    
    if ! validate_configuration; then
        error "Configuration validation failed"
        exit 1
    fi
    
    if ! check_prerequisites; then
        error "Prerequisites check failed"
        exit 1
    fi
    
    # Execute based on mode
    if [[ "$DAEMON_MODE" == "true" ]]; then
        start_daemon
    else
        # Single backup run
        if perform_backup; then
            log "[COMPLETE] Backup operation completed successfully"
            exit 0
        else
            error "[FAILED] Backup operation completed with errors"
            exit 1
        fi
    fi
}

# Execute main function with all arguments
main "$@"