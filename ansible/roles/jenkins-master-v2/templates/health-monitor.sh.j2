#!/bin/bash
# Health Monitoring Script for {{ item.team_name }}
# Generated by Ansible jenkins-master-v2 role

set -euo pipefail

TEAM_NAME="{{ item.team_name }}"
CONTAINER_RUNTIME="{{ jenkins_master_container_runtime }}"
WEB_PORT="{{ item.ports.web }}"
CONFIG_DIR="{{ jenkins_master_custom_build_dir }}"
JENKINS_HOME="{{ jenkins_home_dir }}"
MONITOR_INTERVAL="${MONITOR_INTERVAL:-60}"
LOG_FILE="${JENKINS_HOME}/logs/health-monitor-${TEAM_NAME}.log"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

log() {
    local message="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    echo -e "${BLUE}${message}${NC}"
    echo "$message" >> "$LOG_FILE"
}

error() {
    local message="[ERROR] $1"
    echo -e "${RED}${message}${NC}" >&2
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $message" >> "$LOG_FILE"
}

success() {
    local message="[SUCCESS] $1"
    echo -e "${GREEN}${message}${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $message" >> "$LOG_FILE"
}

warn() {
    local message="[WARNING] $1"
    echo -e "${YELLOW}${message}${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $message" >> "$LOG_FILE"
}

get_active_environment() {
    if [[ -f "${JENKINS_HOME}/${TEAM_NAME}/blue-green-state.json" ]]; then
        grep -o '"active_environment":\s*"[^"]*"' "${JENKINS_HOME}/${TEAM_NAME}/blue-green-state.json" | cut -d'"' -f4
    else
        echo "blue"
    fi
}

quick_health_check() {
    local environment=$(get_active_environment)
    local container_name="jenkins-${TEAM_NAME}-${environment}"
    local health_score=0
    local max_score=4
    
    # Check 1: Container running
    if $CONTAINER_RUNTIME inspect "$container_name" --format='{{ '{{' }}.State.Status{{ '}}' }}' 2>/dev/null | grep -q "running"; then
        ((health_score++))
    fi
    
    # Check 2: Web interface
    if curl -f -s --max-time 5 "http://localhost:${WEB_PORT}/login" &>/dev/null; then
        ((health_score++))
    fi
    
    # Check 3: API responding
    if curl -s --max-time 5 "http://localhost:${WEB_PORT}/api/json" | grep -q '"mode"' 2>/dev/null; then
        ((health_score++))
    fi
    
    # Check 4: Container health (if configured)
    local container_health=$($CONTAINER_RUNTIME inspect "$container_name" --format='{{ '{{' }}.State.Health.Status{{ '}}' }}' 2>/dev/null || echo "N/A")
    if [[ "$container_health" == "healthy" ]] || [[ "$container_health" == "N/A" ]]; then
        ((health_score++))
    fi
    
    echo "$health_score/$max_score"
}

monitor_continuous() {
    log "Starting continuous health monitoring for $TEAM_NAME (interval: ${MONITOR_INTERVAL}s)"
    log "Log file: $LOG_FILE"
    
    local consecutive_failures=0
    local max_failures=3
    
    while true; do
        local health_result=$(quick_health_check)
        local current_env=$(get_active_environment)
        
        if [[ "$health_result" == "4/4" ]]; then
            success "Health check passed: $health_result (environment: $current_env)"
            consecutive_failures=0
        else
            warn "Health check failed: $health_result (environment: $current_env)"
            ((consecutive_failures++))
            
            if [[ $consecutive_failures -ge $max_failures ]]; then
                error "Health check failed $consecutive_failures consecutive times!"
                
                # Optional: Send alert or trigger recovery action
                if command -v mail &>/dev/null && [[ -n "${ALERT_EMAIL:-}" ]]; then
                    echo "Jenkins $TEAM_NAME health check failed $consecutive_failures times. Current score: $health_result" | \
                        mail -s "Jenkins $TEAM_NAME Health Alert" "$ALERT_EMAIL"
                fi
                
                # Optional: Attempt automatic recovery
                if [[ "${AUTO_RECOVERY:-false}" == "true" ]]; then
                    warn "Attempting automatic recovery..."
                    local recovery_script="${JENKINS_HOME}/scripts/blue-green-switch-${TEAM_NAME}.sh"
                    if [[ -x "$recovery_script" ]]; then
                        log "Executing blue-green switch for recovery..."
                        "$recovery_script" switch 2>&1 | tee -a "$LOG_FILE"
                    fi
                fi
                
                consecutive_failures=0  # Reset after alert/recovery
            fi
        fi
        
        sleep "$MONITOR_INTERVAL"
    done
}

show_metrics() {
    local environment=$(get_active_environment)
    local container_name="jenkins-${TEAM_NAME}-${environment}"
    
    echo -e "\n${BLUE}=== Health Metrics for $TEAM_NAME ===${NC}"
    
    # Current health score
    local health_score=$(quick_health_check)
    echo -e "Current Health Score: ${GREEN}$health_score${NC}"
    
    # Container metrics
    if $CONTAINER_RUNTIME inspect "$container_name" &>/dev/null; then
        echo -e "\n${YELLOW}Container Metrics:${NC}"
        local stats=$($CONTAINER_RUNTIME stats "$container_name" --no-stream --format "table {{ '{{' }}.MemUsage{{ '}}' }}\t{{ '{{' }}.CPUPerc{{ '}}' }}\t{{ '{{' }}.NetIO{{ '}}' }}\t{{ '{{' }}.BlockIO{{ '}}' }}" 2>/dev/null || echo "N/A")
        echo "$stats"
        
        # Container uptime
        local started_at=$($CONTAINER_RUNTIME inspect "$container_name" --format='{{ '{{' }}.State.StartedAt{{ '}}' }}' 2>/dev/null)
        if [[ -n "$started_at" ]]; then
            echo -e "\nContainer Started: $started_at"
        fi
    fi
    
    # Recent log entries
    if [[ -f "$LOG_FILE" ]]; then
        echo -e "\n${YELLOW}Recent Health Check Log (last 10 entries):${NC}"
        tail -10 "$LOG_FILE"
    fi
    
    # Jenkins-specific metrics
    echo -e "\n${YELLOW}Jenkins Metrics:${NC}"
    local jenkins_info=$(curl -s --max-time 10 "http://localhost:${WEB_PORT}/api/json?tree=numExecutors,quietingDown,useSecurity" 2>/dev/null || echo "{}")
    if echo "$jenkins_info" | grep -q '"numExecutors"'; then
        echo "Jenkins Info: $jenkins_info"
    else
        echo "Jenkins API not accessible"
    fi
}

cleanup_logs() {
    local retention_days="${LOG_RETENTION_DAYS:-7}"
    log "Cleaning up log files older than $retention_days days..."
    
    find "$(dirname "$LOG_FILE")" -name "health-monitor-*.log" -type f -mtime +$retention_days -delete 2>/dev/null || true
    success "Log cleanup completed"
}

main() {
    case "${1:-monitor}" in
        monitor)
            monitor_continuous
            ;;
        check)
            local health_score=$(quick_health_check)
            local current_env=$(get_active_environment)
            echo "Health Score: $health_score (environment: $current_env)"
            [[ "$health_score" == "4/4" ]] && exit 0 || exit 1
            ;;
        metrics)
            show_metrics
            ;;
        cleanup)
            cleanup_logs
            ;;
        test)
            log "Running health check test..."
            local health_score=$(quick_health_check)
            echo "Test result: $health_score"
            ;;
        *)
            echo "Usage: $0 {monitor|check|metrics|cleanup|test}"
            echo "  monitor   - Start continuous monitoring (default)"
            echo "  check     - Single health check (exit 0 if healthy)"
            echo "  metrics   - Show detailed metrics and stats"
            echo "  cleanup   - Clean up old log files"
            echo "  test      - Test health check function"
            echo ""
            echo "Environment variables:"
            echo "  MONITOR_INTERVAL  - Monitoring interval in seconds (default: 60)"
            echo "  ALERT_EMAIL       - Email address for alerts"
            echo "  AUTO_RECOVERY     - Enable automatic recovery (true/false)"
            echo "  LOG_RETENTION_DAYS - Log retention period (default: 7)"
            exit 1
            ;;
    esac
}

# Set up signal handlers for graceful shutdown
trap 'log "Health monitor shutting down..."; exit 0' TERM INT

main "$@"