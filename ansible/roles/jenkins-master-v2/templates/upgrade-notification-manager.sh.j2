#!/bin/bash
# Upgrade Notification Manager for Jenkins HA Infrastructure
# Handles notifications and alerting during upgrade operations

set -euo pipefail

# Configuration
TEAM_NAME="{{ item.team_name }}"
JENKINS_HOME="{{ jenkins_home_dir }}"
CONFIG_DIR="{{ jenkins_master_custom_build_dir }}"
STATE_FILE="${CONFIG_DIR}/${TEAM_NAME}/blue-green-state.json"
NOTIFICATION_CONFIG="${CONFIG_DIR}/config/notification-config.json"
TEAM_CONFIG_PATH="${CONFIG_DIR}/${TEAM_NAME}"
WEBHOOK_TIMEOUT="{{ notification_webhook_timeout | default(30) }}"
RETRY_ATTEMPTS="{{ notification_retry_attempts | default(3) }}"
RETRY_DELAY="{{ notification_retry_delay | default(5) }}"

# Team-specific notification settings  
TEAM_SLACK_CHANNEL="{{ item.slack_channel | default('#jenkins-alerts') }}"
TEAM_EMAIL_LIST="{{ item.notification_emails | default('') }}"
UPGRADE_LOG_DIR="${CONFIG_DIR}/${TEAM_NAME}/upgrade-logs"

# Notification channels
SLACK_WEBHOOK_URL="{{ slack_webhook_url | default('') }}"
TEAMS_WEBHOOK_URL="{{ teams_webhook_url | default('') }}"
EMAIL_SMTP_SERVER="{{ email_smtp_server | default('') }}"
EMAIL_FROM="{{ email_from | default('jenkins@company.com') }}"
EMAIL_RECIPIENTS="{{ email_recipients | default('') }}"
JIRA_URL="{{ jira_url | default('') }}"
JIRA_PROJECT="{{ jira_project | default('') }}"
PAGERDUTY_INTEGRATION_KEY="{{ pagerduty_integration_key | default('') }}"

# Colors and formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Logging functions
log() { echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
warn() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
info() { echo -e "${CYAN}[INFO]${NC} $1"; }

# Notification templates
declare -A NOTIFICATION_TEMPLATES

# Display usage
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

OPTIONS:
    --event TYPE                Event type: start, progress, success, failure, warning
    --upgrade-type TYPE         Upgrade type: jenkins_version, plugins, job_dsl, infrastructure
    --team TEAM                 Team name
    --environment ENV           Environment name
    --message TEXT              Custom message
    --details JSON              Additional details (JSON format)
    --severity LEVEL            Severity: low, medium, high, critical
    --channels CHANNELS         Comma-separated list of channels: slack,teams,email,jira,pagerduty
    --template NAME             Use predefined template
    --attachment FILE           Attach file to notification
    --dry-run                   Show what would be sent without sending
    --test                      Send test notification
    --help                      Show this help

EVENT TYPES:
    start                       Upgrade operation started
    progress                    Upgrade progress update
    success                     Upgrade completed successfully
    failure                     Upgrade failed
    warning                     Warning during upgrade
    rollback                    Rollback initiated
    validation                  Validation results
    consensus                   Multi-VM consensus events

EXAMPLES:
    # Notify upgrade start
    $0 --event start --upgrade-type jenkins_version --team devops \
       --environment green --severity medium --channels slack,email
    
    # Notify upgrade failure with details
    $0 --event failure --upgrade-type plugins --team devops \
       --message "Plugin compatibility check failed" \
       --details '{"failed_plugins": ["workflow-aggregator", "docker-workflow"]}' \
       --severity critical --channels slack,teams,pagerduty
    
    # Send test notification
    $0 --test --channels slack

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --event)
                EVENT_TYPE="$2"
                shift 2
                ;;
            --upgrade-type)
                UPGRADE_TYPE="$2"
                shift 2
                ;;
            --team)
                TEAM_NAME="$2"
                shift 2
                ;;
            --environment)
                ENVIRONMENT="$2"
                shift 2
                ;;
            --message)
                CUSTOM_MESSAGE="$2"
                shift 2
                ;;
            --details)
                ADDITIONAL_DETAILS="$2"
                shift 2
                ;;
            --severity)
                SEVERITY="$2"
                shift 2
                ;;
            --channels)
                NOTIFICATION_CHANNELS="$2"
                shift 2
                ;;
            --template)
                TEMPLATE_NAME="$2"
                shift 2
                ;;
            --attachment)
                ATTACHMENT_FILE="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --test)
                TEST_MODE=true
                shift
                ;;
            --help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    # Set defaults
    EVENT_TYPE="${EVENT_TYPE:-info}"
    SEVERITY="${SEVERITY:-medium}"
    NOTIFICATION_CHANNELS="${NOTIFICATION_CHANNELS:-slack}"
}

# Initialize notification templates
init_notification_templates() {
    NOTIFICATION_TEMPLATES["upgrade_start"]="🚀 Jenkins Upgrade Started\n**Team:** {team}\n**Type:** {upgrade_type}\n**Environment:** {environment}\n**Started:** {timestamp}"
    
    NOTIFICATION_TEMPLATES["upgrade_progress"]="⏳ Jenkins Upgrade Progress\n**Team:** {team}\n**Progress:** {message}\n**Environment:** {environment}\n**Status:** In Progress"
    
    NOTIFICATION_TEMPLATES["upgrade_success"]="✅ Jenkins Upgrade Completed Successfully\n**Team:** {team}\n**Type:** {upgrade_type}\n**Environment:** {environment}\n**Completed:** {timestamp}\n**Duration:** {duration}"
    
    NOTIFICATION_TEMPLATES["upgrade_failure"]="❌ Jenkins Upgrade Failed\n**Team:** {team}\n**Type:** {upgrade_type}\n**Environment:** {environment}\n**Error:** {message}\n**Failed at:** {timestamp}"
    
    NOTIFICATION_TEMPLATES["upgrade_warning"]="⚠️ Jenkins Upgrade Warning\n**Team:** {team}\n**Warning:** {message}\n**Environment:** {environment}\n**Timestamp:** {timestamp}"
    
    NOTIFICATION_TEMPLATES["rollback_initiated"]="🔄 Jenkins Rollback Initiated\n**Team:** {team}\n**Environment:** {environment}\n**Reason:** {message}\n**Initiated:** {timestamp}"
    
    NOTIFICATION_TEMPLATES["validation_results"]="🔍 Validation Results\n**Team:** {team}\n**Environment:** {environment}\n**Result:** {message}\n**Score:** {score}/100"
    
    NOTIFICATION_TEMPLATES["consensus_update"]="🤝 Multi-VM Consensus Update\n**Operation:** {upgrade_type}\n**Status:** {message}\n**VMs Ready:** {ready_vms}\n**Timestamp:** {timestamp}"
    
    NOTIFICATION_TEMPLATES["traffic_switch"]="🔀 Traffic Switch\n**Team:** {team}\n**From:** {source_env}\n**To:** {target_env}\n**Traffic:** {traffic_percent}%\n**Status:** {message}"
}

# Load notification configuration
load_notification_config() {
    if [[ -f "$NOTIFICATION_CONFIG" ]]; then
        local config=$(cat "$NOTIFICATION_CONFIG")
        
        # Override defaults with config values
        SLACK_WEBHOOK_URL=$(echo "$config" | jq -r '.slack.webhook_url // empty')
        TEAMS_WEBHOOK_URL=$(echo "$config" | jq -r '.teams.webhook_url // empty')
        EMAIL_SMTP_SERVER=$(echo "$config" | jq -r '.email.smtp_server // empty')
        EMAIL_FROM=$(echo "$config" | jq -r '.email.from // "jenkins@company.com"')
        EMAIL_RECIPIENTS=$(echo "$config" | jq -r '.email.recipients // empty')
        JIRA_URL=$(echo "$config" | jq -r '.jira.url // empty')
        JIRA_PROJECT=$(echo "$config" | jq -r '.jira.project // empty')
        PAGERDUTY_INTEGRATION_KEY=$(echo "$config" | jq -r '.pagerduty.integration_key // empty')
        
        # Load team-specific overrides
        local team_config=$(echo "$config" | jq -r ".teams.\"$TEAM_NAME\" // {}")
        if [[ "$team_config" != "{}" ]]; then
            local team_slack=$(echo "$team_config" | jq -r '.slack.webhook_url // empty')
            local team_email=$(echo "$team_config" | jq -r '.email.recipients // empty')
            
            [[ -n "$team_slack" ]] && SLACK_WEBHOOK_URL="$team_slack"
            [[ -n "$team_email" ]] && EMAIL_RECIPIENTS="$team_email"
        fi
    fi
}

# Get notification template
get_notification_template() {
    local template_key="$1"
    
    if [[ -n "${TEMPLATE_NAME:-}" ]]; then
        template_key="$TEMPLATE_NAME"
    fi
    
    echo "${NOTIFICATION_TEMPLATES[$template_key]:-${NOTIFICATION_TEMPLATES["upgrade_progress"]}}"
}

# Replace template variables
replace_template_variables() {
    local template="$1"
    local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    
    # Replace standard variables
    template=${template//\{team\}/"$TEAM_NAME"}
    template=${template//\{upgrade_type\}/"${UPGRADE_TYPE:-unknown}"}
    template=${template//\{environment\}/"${ENVIRONMENT:-unknown}"}
    template=${template//\{message\}/"${CUSTOM_MESSAGE:-No additional details}"}
    template=${template//\{timestamp\}/"$timestamp"}
    template=${template//\{severity\}/"$SEVERITY"}
    
    # Replace additional details if provided
    if [[ -n "${ADDITIONAL_DETAILS:-}" ]]; then
        # Extract common fields from JSON details
        local score=$(echo "$ADDITIONAL_DETAILS" | jq -r '.score // empty')
        local duration=$(echo "$ADDITIONAL_DETAILS" | jq -r '.duration // empty')
        local ready_vms=$(echo "$ADDITIONAL_DETAILS" | jq -r '.ready_vms // empty')
        local source_env=$(echo "$ADDITIONAL_DETAILS" | jq -r '.source_env // empty')
        local target_env=$(echo "$ADDITIONAL_DETAILS" | jq -r '.target_env // empty')
        local traffic_percent=$(echo "$ADDITIONAL_DETAILS" | jq -r '.traffic_percent // empty')
        
        [[ -n "$score" ]] && template=${template//\{score\}/"$score"}
        [[ -n "$duration" ]] && template=${template//\{duration\}/"$duration"}
        [[ -n "$ready_vms" ]] && template=${template//\{ready_vms\}/"$ready_vms"}
        [[ -n "$source_env" ]] && template=${template//\{source_env\}/"$source_env"}
        [[ -n "$target_env" ]] && template=${template//\{target_env\}/"$target_env"}
        [[ -n "$traffic_percent" ]] && template=${template//\{traffic_percent\}/"$traffic_percent"}
    fi
    
    echo "$template"
}

# Get severity color for Slack
get_severity_color() {
    case "$SEVERITY" in
        "low") echo "good" ;;
        "medium") echo "warning" ;;
        "high") echo "#ff9500" ;;
        "critical") echo "danger" ;;
        *) echo "#0080ff" ;;
    esac
}

# Send Slack notification
send_slack_notification() {
    local message="$1"
    
    if [[ -z "$SLACK_WEBHOOK_URL" ]]; then
        warn "Slack webhook URL not configured"
        return 1
    fi
    
    log "Sending Slack notification..."
    
    local color=$(get_severity_color)
    local payload=$(cat <<EOF
{
    "username": "Jenkins HA Bot",
    "icon_emoji": ":jenkins:",
    "attachments": [
        {
            "color": "$color",
            "title": "Jenkins ${UPGRADE_TYPE:-Upgrade} - ${EVENT_TYPE^}",
            "text": "$message",
            "fields": [
                {
                    "title": "Team",
                    "value": "$TEAM_NAME",
                    "short": true
                },
                {
                    "title": "Environment",
                    "value": "${ENVIRONMENT:-N/A}",
                    "short": true
                },
                {
                    "title": "Severity",
                    "value": "${SEVERITY^}",
                    "short": true
                },
                {
                    "title": "Timestamp",
                    "value": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                    "short": true
                }
            ],
            "footer": "Jenkins HA Infrastructure",
            "ts": $(date +%s)
        }
    ]
}
EOF
)
    
    if [[ "${DRY_RUN:-false}" == "true" ]]; then
        info "[DRY RUN] Would send Slack payload:"
        echo "$payload" | jq .
        return 0
    fi
    
    local response=$(curl -s -w "%{http_code}" -X POST \
        -H "Content-Type: application/json" \
        -d "$payload" \
        --max-time "$WEBHOOK_TIMEOUT" \
        "$SLACK_WEBHOOK_URL")
    
    local http_code=${response: -3}
    if [[ "$http_code" =~ ^2[0-9][0-9]$ ]]; then
        success "Slack notification sent successfully"
        return 0
    else
        error "Failed to send Slack notification (HTTP $http_code)"
        return 1
    fi
}

# Send Teams notification
send_teams_notification() {
    local message="$1"
    
    if [[ -z "$TEAMS_WEBHOOK_URL" ]]; then
        warn "Teams webhook URL not configured"
        return 1
    fi
    
    log "Sending Teams notification..."
    
    local color=$(get_severity_color)
    local payload=$(cat <<EOF
{
    "@type": "MessageCard",
    "@context": "http://schema.org/extensions",
    "themeColor": "$color",
    "summary": "Jenkins ${UPGRADE_TYPE:-Upgrade} - ${EVENT_TYPE^}",
    "sections": [
        {
            "activityTitle": "Jenkins ${UPGRADE_TYPE:-Upgrade} - ${EVENT_TYPE^}",
            "activitySubtitle": "Team: $TEAM_NAME | Environment: ${ENVIRONMENT:-N/A}",
            "activityImage": "https://jenkins.io/images/jenkins-logo.png",
            "text": "$message",
            "facts": [
                {
                    "name": "Team",
                    "value": "$TEAM_NAME"
                },
                {
                    "name": "Environment",
                    "value": "${ENVIRONMENT:-N/A}"
                },
                {
                    "name": "Severity",
                    "value": "${SEVERITY^}"
                },
                {
                    "name": "Timestamp",
                    "value": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                }
            ]
        }
    ]
}
EOF
)
    
    if [[ "${DRY_RUN:-false}" == "true" ]]; then
        info "[DRY RUN] Would send Teams payload:"
        echo "$payload" | jq .
        return 0
    fi
    
    local response=$(curl -s -w "%{http_code}" -X POST \
        -H "Content-Type: application/json" \
        -d "$payload" \
        --max-time "$WEBHOOK_TIMEOUT" \
        "$TEAMS_WEBHOOK_URL")
    
    local http_code=${response: -3}
    if [[ "$http_code" =~ ^2[0-9][0-9]$ ]]; then
        success "Teams notification sent successfully"
        return 0
    else
        error "Failed to send Teams notification (HTTP $http_code)"
        return 1
    fi
}

# Send email notification
send_email_notification() {
    local message="$1"
    
    if [[ -z "$EMAIL_SMTP_SERVER" || -z "$EMAIL_RECIPIENTS" ]]; then
        warn "Email configuration incomplete"
        return 1
    fi
    
    log "Sending email notification..."
    
    local subject="Jenkins ${UPGRADE_TYPE:-Upgrade} ${EVENT_TYPE^} - Team: $TEAM_NAME"
    local email_body=$(cat <<EOF
Jenkins HA Infrastructure Notification

Event: ${EVENT_TYPE^}
Upgrade Type: ${UPGRADE_TYPE:-N/A}
Team: $TEAM_NAME
Environment: ${ENVIRONMENT:-N/A}
Severity: ${SEVERITY^}
Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)

Details:
$message

$(if [[ -n "${ADDITIONAL_DETAILS:-}" ]]; then
    echo "Additional Information:"
    echo "$ADDITIONAL_DETAILS" | jq .
fi)

---
This notification was generated automatically by Jenkins HA Infrastructure.
EOF
)
    
    if [[ "${DRY_RUN:-false}" == "true" ]]; then
        info "[DRY RUN] Would send email:"
        echo "To: $EMAIL_RECIPIENTS"
        echo "Subject: $subject"
        echo "Body:"
        echo "$email_body"
        return 0
    fi
    
    # Use sendmail or mail command
    if command -v sendmail &>/dev/null; then
        {
            echo "To: $EMAIL_RECIPIENTS"
            echo "From: $EMAIL_FROM"
            echo "Subject: $subject"
            echo "Content-Type: text/plain; charset=UTF-8"
            echo
            echo "$email_body"
        } | sendmail "$EMAIL_RECIPIENTS"
        
        success "Email notification sent successfully"
        return 0
    elif command -v mail &>/dev/null; then
        echo "$email_body" | mail -s "$subject" -r "$EMAIL_FROM" "$EMAIL_RECIPIENTS"
        
        success "Email notification sent successfully"
        return 0
    else
        error "No email command available (sendmail or mail)"
        return 1
    fi
}

# Create JIRA issue
create_jira_issue() {
    local message="$1"
    
    if [[ -z "$JIRA_URL" || -z "$JIRA_PROJECT" ]]; then
        warn "JIRA configuration incomplete"
        return 1
    fi
    
    # Only create JIRA issues for failures and critical events
    if [[ "$EVENT_TYPE" != "failure" && "$SEVERITY" != "critical" ]]; then
        info "Skipping JIRA issue creation for non-critical event"
        return 0
    fi
    
    log "Creating JIRA issue..."
    
    local issue_summary="Jenkins ${UPGRADE_TYPE:-Upgrade} ${EVENT_TYPE^} - Team: $TEAM_NAME"
    local issue_description=$(cat <<EOF
Jenkins HA Infrastructure Issue

Event Type: ${EVENT_TYPE^}
Upgrade Type: ${UPGRADE_TYPE:-N/A}
Team: $TEAM_NAME
Environment: ${ENVIRONMENT:-N/A}
Severity: ${SEVERITY^}
Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)

Description:
$message

$(if [[ -n "${ADDITIONAL_DETAILS:-}" ]]; then
    echo "Additional Details:"
    echo "$ADDITIONAL_DETAILS"
fi)

This issue was created automatically by Jenkins HA Infrastructure.
EOF
)
    
    local issue_payload=$(cat <<EOF
{
    "fields": {
        "project": {
            "key": "$JIRA_PROJECT"
        },
        "summary": "$issue_summary",
        "description": "$issue_description",
        "issuetype": {
            "name": "Bug"
        },
        "priority": {
            "name": "$(if [[ "$SEVERITY" == "critical" ]]; then echo "Critical"; elif [[ "$SEVERITY" == "high" ]]; then echo "High"; else echo "Medium"; fi)"
        },
        "labels": ["jenkins-ha", "automation", "${TEAM_NAME}", "${UPGRADE_TYPE:-upgrade}"]
    }
}
EOF
)
    
    if [[ "${DRY_RUN:-false}" == "true" ]]; then
        info "[DRY RUN] Would create JIRA issue:"
        echo "$issue_payload" | jq .
        return 0
    fi
    
    # Note: This requires JIRA authentication configuration
    # Implementation would depend on specific JIRA setup (API token, username, etc.)
    info "JIRA issue creation would be implemented based on your JIRA configuration"
    return 0
}

# Send PagerDuty alert
send_pagerduty_alert() {
    local message="$1"
    
    if [[ -z "$PAGERDUTY_INTEGRATION_KEY" ]]; then
        warn "PagerDuty integration key not configured"
        return 1
    fi
    
    # Only send PagerDuty alerts for high severity events
    if [[ "$SEVERITY" != "high" && "$SEVERITY" != "critical" ]]; then
        info "Skipping PagerDuty alert for low/medium severity event"
        return 0
    fi
    
    log "Sending PagerDuty alert..."
    
    local event_action="trigger"
    if [[ "$EVENT_TYPE" == "success" ]]; then
        event_action="resolve"
    fi
    
    local payload=$(cat <<EOF
{
    "routing_key": "$PAGERDUTY_INTEGRATION_KEY",
    "event_action": "$event_action",
    "dedup_key": "jenkins-ha-${TEAM_NAME}-${UPGRADE_TYPE:-upgrade}",
    "payload": {
        "summary": "Jenkins ${UPGRADE_TYPE:-Upgrade} ${EVENT_TYPE^} - Team: $TEAM_NAME",
        "source": "jenkins-ha-infrastructure",
        "severity": "$(if [[ "$SEVERITY" == "critical" ]]; then echo "critical"; elif [[ "$SEVERITY" == "high" ]]; then echo "error"; else echo "warning"; fi)",
        "component": "jenkins-${TEAM_NAME}",
        "group": "jenkins-ha",
        "class": "${UPGRADE_TYPE:-upgrade}",
        "custom_details": {
            "team": "$TEAM_NAME",
            "environment": "${ENVIRONMENT:-N/A}",
            "upgrade_type": "${UPGRADE_TYPE:-N/A}",
            "event_type": "$EVENT_TYPE",
            "message": "$message",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
    }
}
EOF
)
    
    if [[ "${DRY_RUN:-false}" == "true" ]]; then
        info "[DRY RUN] Would send PagerDuty payload:"
        echo "$payload" | jq .
        return 0
    fi
    
    local response=$(curl -s -w "%{http_code}" -X POST \
        -H "Content-Type: application/json" \
        -d "$payload" \
        --max-time "$WEBHOOK_TIMEOUT" \
        "https://events.pagerduty.com/v2/enqueue")
    
    local http_code=${response: -3}
    if [[ "$http_code" =~ ^2[0-9][0-9]$ ]]; then
        success "PagerDuty alert sent successfully"
        return 0
    else
        error "Failed to send PagerDuty alert (HTTP $http_code)"
        return 1
    fi
}

# Send notifications with retry logic
send_notification_with_retry() {
    local channel="$1"
    local message="$2"
    local attempt=1
    
    while [[ $attempt -le $RETRY_ATTEMPTS ]]; do
        log "Sending $channel notification (attempt $attempt/$RETRY_ATTEMPTS)..."
        
        case "$channel" in
            "slack")
                if send_slack_notification "$message"; then
                    return 0
                fi
                ;;
            "teams")
                if send_teams_notification "$message"; then
                    return 0
                fi
                ;;
            "email")
                if send_email_notification "$message"; then
                    return 0
                fi
                ;;
            "jira")
                if create_jira_issue "$message"; then
                    return 0
                fi
                ;;
            "pagerduty")
                if send_pagerduty_alert "$message"; then
                    return 0
                fi
                ;;
            *)
                error "Unknown notification channel: $channel"
                return 1
                ;;
        esac
        
        if [[ $attempt -lt $RETRY_ATTEMPTS ]]; then
            warn "Attempt $attempt failed, retrying in ${RETRY_DELAY}s..."
            sleep "$RETRY_DELAY"
        fi
        
        ((attempt++))
    done
    
    error "Failed to send $channel notification after $RETRY_ATTEMPTS attempts"
    return 1
}

# Send test notification
send_test_notification() {
    log "Sending test notification..."
    
    EVENT_TYPE="test"
    CUSTOM_MESSAGE="This is a test notification from Jenkins HA Infrastructure"
    SEVERITY="low"
    UPGRADE_TYPE="test"
    ENVIRONMENT="test"
    
    local template=$(get_notification_template "upgrade_progress")
    local message=$(replace_template_variables "$template")
    
    send_notifications "$message"
}

# Main notification sending function
send_notifications() {
    local message="$1"
    local channels=(${NOTIFICATION_CHANNELS//,/ })
    local failed_channels=()
    local successful_channels=()
    
    log "Sending notifications to ${#channels[@]} channels: ${channels[*]}"
    
    for channel in "${channels[@]}"; do
        if send_notification_with_retry "$channel" "$message"; then
            successful_channels+=("$channel")
        else
            failed_channels+=("$channel")
        fi
    done
    
    if [[ ${#successful_channels[@]} -gt 0 ]]; then
        success "Notifications sent successfully to: ${successful_channels[*]}"
    fi
    
    if [[ ${#failed_channels[@]} -gt 0 ]]; then
        error "Failed to send notifications to: ${failed_channels[*]}"
        return 1
    fi
    
    return 0
}

# Main execution function
main() {
    parse_args "$@"
    
    # Initialize
    init_notification_templates
    load_notification_config
    
    # Handle test mode
    if [[ "${TEST_MODE:-false}" == "true" ]]; then
        send_test_notification
        return $?
    fi
    
    # Validate required parameters
    if [[ -z "$EVENT_TYPE" ]]; then
        error "Event type is required"
        usage
        return 1
    fi
    
    log "Processing notification event: $EVENT_TYPE"
    
    # Get appropriate template
    local template_key
    case "$EVENT_TYPE" in
        "start") template_key="upgrade_start" ;;
        "progress") template_key="upgrade_progress" ;;
        "success") template_key="upgrade_success" ;;
        "failure") template_key="upgrade_failure" ;;
        "warning") template_key="upgrade_warning" ;;
        "rollback") template_key="rollback_initiated" ;;
        "validation") template_key="validation_results" ;;
        "consensus") template_key="consensus_update" ;;
        "traffic_switch") template_key="traffic_switch" ;;
        *) template_key="upgrade_progress" ;;
    esac
    
    # Generate message from template
    local template=$(get_notification_template "$template_key")
    local message=$(replace_template_variables "$template")
    
    # Add custom message if provided
    if [[ -n "${CUSTOM_MESSAGE:-}" ]]; then
        message="${message}\n\n**Additional Details:** ${CUSTOM_MESSAGE}"
    fi
    
    # Send notifications
    send_notifications "$message"
}

# Handle script termination
trap 'error "Notification manager interrupted"; exit 130' INT TERM

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi