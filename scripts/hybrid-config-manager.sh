#!/bin/bash
# Hybrid Configuration Manager for Jenkins HA Infrastructure
# Dynamically configures system based on detected architecture

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="/etc/jenkins-ha"
BACKUP_DIR="/var/backup/jenkins-ha-configs"
ACTION="detect"
DEPLOYMENT_MODE=""
FORCE=false
DRY_RUN=false

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging functions
log() { echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
warn() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

# Usage
usage() {
    cat <<EOF
Usage: $0 [ACTION] [OPTIONS]

ACTIONS:
    detect                  Detect and display current architecture
    configure               Configure system based on detected architecture
    switch                  Switch between deployment modes
    validate                Validate current configuration
    backup                  Backup current configuration
    restore                 Restore from backup

OPTIONS:
    --mode MODE             Force specific deployment mode (container, multi_vm)
    --config-dir DIR        Configuration directory (default: $CONFIG_DIR)
    --backup-dir DIR        Backup directory (default: $BACKUP_DIR)
    --force                 Force configuration changes
    --dry-run               Show what would be done without making changes
    --help                  Show this help

EXAMPLES:
    # Auto-detect and configure
    $0 configure

    # Force container mode configuration
    $0 configure --mode container --force

    # Validate current setup
    $0 validate

    # Switch to multi-VM mode
    $0 switch --mode multi_vm

EOF
}

# Parse arguments
parse_args() {
    if [[ $# -gt 0 ]]; then
        ACTION="$1"
        shift
    fi
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --mode)
                DEPLOYMENT_MODE="$2"
                shift 2
                ;;
            --config-dir)
                CONFIG_DIR="$2"
                shift 2
                ;;
            --backup-dir)
                BACKUP_DIR="$2"
                shift 2
                ;;
            --force)
                FORCE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
}

# Ensure directories exist
ensure_directories() {
    local dirs=("$CONFIG_DIR" "$BACKUP_DIR")
    
    for dir in "${dirs[@]}"; do
        if [[ "$DRY_RUN" == "true" ]]; then
            log "DRY RUN: Would create directory: $dir"
        else
            if [[ ! -d "$dir" ]]; then
                mkdir -p "$dir"
                [[ "$?" -eq 0 ]] && log "Created directory: $dir" || error "Failed to create directory: $dir"
            fi
        fi
    done
}

# Detect current architecture
detect_architecture() {
    log "Detecting current architecture..."
    
    if [[ -f "$SCRIPT_DIR/architecture-detector.sh" ]]; then
        bash "$SCRIPT_DIR/architecture-detector.sh" --format json
    else
        error "Architecture detector script not found: $SCRIPT_DIR/architecture-detector.sh"
        return 1
    fi
}

# Generate container mode configuration
generate_container_config() {
    local container_runtime="${1:-docker}"
    local teams="${2:-devops,developer}"
    
    cat <<EOF
# Container Mode Configuration
# Generated by hybrid-config-manager.sh on $(date)

deployment_mode: container
container_runtime: $container_runtime

# Container coordination settings
multi_vm_coordination:
  enabled: true
  deployment_mode: container
  container_coordination:
    enabled: true
    container_runtime: $container_runtime
    container_network: jenkins-network
    container_subnet: "172.20.0.0/16"
    shared_storage: "/var/jenkins_home"

# HAProxy configuration for container mode
haproxy_container_config:
  enabled: true
  container_name: "haproxy-lb"
  stats_port: 8404
  admin_port: 8405
  backend_discovery: "container_dns"

# Jenkins teams container configuration
jenkins_teams_container_config:
$(IFS=',' read -ra TEAM_ARRAY <<< "$teams"; for team in "${TEAM_ARRAY[@]}"; do
  cat <<EOT
  $team:
    blue_container: "jenkins-${team}-blue"
    green_container: "jenkins-${team}-green"
    active_environment: "blue"
    blue_green_enabled: true
EOT
done)

# Upgrade framework configuration
upgrade_framework:
  container_mode:
    enabled: true
    coordinator_script: "multi-vm-coordinator.sh"
    validation_script: "universal-upgrade-validator.sh"
    canary_controller: "canary-traffic-controller.sh"

# Monitoring configuration
monitoring_container_config:
  prometheus_container: "prometheus-jenkins"
  grafana_container: "grafana-jenkins"
  container_metrics: true
EOF
}

# Generate multi-VM mode configuration
generate_multi_vm_config() {
    local vm_count="${1:-2}"
    local teams="${2:-devops,developer}"
    
    cat <<EOF
# Multi-VM Mode Configuration
# Generated by hybrid-config-manager.sh on $(date)

deployment_mode: multi_vm
vm_count: $vm_count

# Multi-VM coordination settings
multi_vm_coordination:
  enabled: true
  deployment_mode: multi_vm
  consensus_algorithm: "majority"
  quorum_size: $(( (vm_count / 2) + 1 ))
  coordination_port: 8765
  heartbeat_interval: 30
  consensus_timeout: 300

# VM health check configuration
vm_health_checks:
  enabled: true
  memory_threshold: 512
  disk_threshold: 1024
  cpu_threshold: 80
  network_timeout: 10

# HAProxy configuration for multi-VM mode
haproxy_multi_vm_config:
  enabled: true
  cluster_mode: true
  vip_enabled: true
  keepalived_enabled: true

# Jenkins teams multi-VM configuration
jenkins_teams_multi_vm_config:
$(IFS=',' read -ra TEAM_ARRAY <<< "$teams"; for team in "${TEAM_ARRAY[@]}"; do
  cat <<EOT
  $team:
    distributed_masters: true
    failover_enabled: true
    cross_vm_sync: true
EOT
done)

# Shared storage configuration
shared_storage_config:
  type: "nfs"  # or glusterfs
  high_availability: true
  replication_enabled: true

# Upgrade framework configuration
upgrade_framework:
  multi_vm_mode:
    enabled: true
    distributed_coordination: true
    consensus_required: true
    rollback_coordination: true
EOF
}

# Apply configuration
apply_configuration() {
    local config_content="$1"
    local config_file="$CONFIG_DIR/jenkins-ha-config.yml"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY RUN: Would write configuration to: $config_file"
        log "Configuration content:"
        echo "$config_content"
        return 0
    fi
    
    # Backup existing configuration
    if [[ -f "$config_file" ]]; then
        local backup_file="$BACKUP_DIR/jenkins-ha-config-$(date +%Y%m%d-%H%M%S).yml"
        cp "$config_file" "$backup_file"
        log "Backed up existing configuration to: $backup_file"
    fi
    
    # Write new configuration
    echo "$config_content" > "$config_file"
    
    if [[ "$?" -eq 0 ]]; then
        success "Configuration written to: $config_file"
        return 0
    else
        error "Failed to write configuration"
        return 1
    fi
}

# Configure system based on architecture
configure_system() {
    log "Configuring system for Jenkins HA..."
    
    local deployment_mode="$DEPLOYMENT_MODE"
    
    # Auto-detect if not specified
    if [[ -z "$deployment_mode" ]]; then
        local detection_result
        detection_result=$(detect_architecture)
        
        if [[ "$?" -eq 0 ]]; then
            deployment_mode=$(echo "$detection_result" | jq -r '.deployment_mode' 2>/dev/null || echo "unknown")
            log "Auto-detected deployment mode: $deployment_mode"
        else
            error "Failed to detect architecture"
            return 1
        fi
    fi
    
    case "$deployment_mode" in
        "container")
            log "Configuring for container-based deployment..."
            
            # Detect container runtime
            local container_runtime="docker"
            if command -v podman &>/dev/null && podman info &>/dev/null; then
                container_runtime="podman"
            fi
            
            local config_content
            config_content=$(generate_container_config "$container_runtime" "devops,developer")
            apply_configuration "$config_content"
            
            # Apply container-specific configurations
            configure_container_mode "$container_runtime"
            ;;
            
        "multi_vm")
            log "Configuring for multi-VM deployment..."
            
            local config_content
            config_content=$(generate_multi_vm_config "2" "devops,developer")
            apply_configuration "$config_content"
            
            # Apply multi-VM specific configurations
            configure_multi_vm_mode
            ;;
            
        *)
            error "Unknown or unsupported deployment mode: $deployment_mode"
            return 1
            ;;
    esac
}

# Configure container mode specifics
configure_container_mode() {
    local container_runtime="$1"
    
    log "Applying container-mode specific configurations..."
    
    # Create container network if it doesn't exist
    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY RUN: Would create container network: jenkins-network"
    else
        if ! $container_runtime network ls | grep -q "jenkins-network"; then
            $container_runtime network create \
                --driver bridge \
                --subnet=172.20.0.0/16 \
                --gateway=172.20.0.1 \
                jenkins-network
            success "Created container network: jenkins-network"
        else
            log "Container network already exists: jenkins-network"
        fi
    fi
    
    # Create shared volume if it doesn't exist
    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY RUN: Would create shared volume: jenkins_home"
    else
        if ! $container_runtime volume ls | grep -q "jenkins_home"; then
            $container_runtime volume create jenkins_home
            success "Created shared volume: jenkins_home"
        else
            log "Shared volume already exists: jenkins_home"
        fi
    fi
    
    # Generate systemd service templates for containers
    generate_container_systemd_services "$container_runtime"
}

# Configure multi-VM mode specifics
configure_multi_vm_mode() {
    log "Applying multi-VM specific configurations..."
    
    # Configure SSH key distribution (if needed)
    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY RUN: Would configure SSH key distribution for multi-VM coordination"
    else
        configure_ssh_keys
    fi
    
    # Configure shared storage
    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY RUN: Would configure shared storage for multi-VM setup"
    else
        configure_shared_storage
    fi
    
    # Configure firewall rules for multi-VM communication
    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY RUN: Would configure firewall rules for multi-VM communication"
    else
        configure_firewall_rules
    fi
}

# Generate systemd service templates for containers
generate_container_systemd_services() {
    local container_runtime="$1"
    local systemd_dir="/etc/systemd/system"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY RUN: Would generate systemd service templates in: $systemd_dir"
        return 0
    fi
    
    # Jenkins container service template
    cat > "$systemd_dir/jenkins-container@.service" <<EOF
[Unit]
Description=Jenkins Container %i
After=docker.service
Requires=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=$container_runtime run -d \\
    --name jenkins-%i \\
    --network jenkins-network \\
    --volume jenkins_home:/var/jenkins_home \\
    --env JENKINS_OPTS="--httpPort=8080" \\
    jenkins/jenkins:lts
ExecStop=$container_runtime stop jenkins-%i
ExecStopPost=$container_runtime rm jenkins-%i
Restart=on-failure
RestartSec=30

[Install]
WantedBy=multi-user.target
EOF
    
    success "Created systemd service template: jenkins-container@.service"
    
    # Reload systemd
    systemctl daemon-reload
}

# Configure SSH keys for multi-VM coordination
configure_ssh_keys() {
    log "Configuring SSH keys for multi-VM coordination..."
    
    local ssh_dir="/root/.ssh"
    local key_file="$ssh_dir/jenkins_ha_key"
    
    # Generate SSH key if it doesn't exist
    if [[ ! -f "$key_file" ]]; then
        ssh-keygen -t rsa -b 4096 -f "$key_file" -N "" -C "jenkins-ha-coordination"
        success "Generated SSH key for Jenkins HA coordination"
    fi
    
    # Add to authorized_keys
    cat "$key_file.pub" >> "$ssh_dir/authorized_keys"
    chmod 600 "$ssh_dir/authorized_keys"
    
    log "SSH key configuration completed"
}

# Configure shared storage
configure_shared_storage() {
    log "Configuring shared storage for multi-VM setup..."
    
    local storage_dir="/opt/jenkins-shared"
    
    # Create shared storage directory
    if [[ ! -d "$storage_dir" ]]; then
        mkdir -p "$storage_dir"
        chmod 755 "$storage_dir"
        success "Created shared storage directory: $storage_dir"
    fi
    
    # Basic NFS export configuration (simplified)
    local exports_file="/etc/exports"
    local export_line="$storage_dir *(rw,sync,no_subtree_check)"
    
    if ! grep -q "$storage_dir" "$exports_file" 2>/dev/null; then
        echo "$export_line" >> "$exports_file"
        success "Added NFS export configuration"
    fi
}

# Configure firewall rules
configure_firewall_rules() {
    log "Configuring firewall rules for multi-VM communication..."
    
    # Jenkins ports
    local jenkins_ports=(8080 8081 8082 8083 50000 50001 50002 50003)
    
    # Coordination port
    local coordination_port=8765
    
    # Open ports using firewall-cmd if available
    if command -v firewall-cmd &>/dev/null; then
        for port in "${jenkins_ports[@]}"; do
            firewall-cmd --permanent --add-port="$port/tcp" &>/dev/null || true
        done
        
        firewall-cmd --permanent --add-port="$coordination_port/tcp" &>/dev/null || true
        firewall-cmd --reload &>/dev/null || true
        
        success "Configured firewall rules"
    else
        warn "firewall-cmd not available, please configure firewall manually"
    fi
}

# Validate current configuration
validate_configuration() {
    log "Validating current configuration..."
    
    local config_file="$CONFIG_DIR/jenkins-ha-config.yml"
    local validation_passed=true
    
    # Check if configuration file exists
    if [[ ! -f "$config_file" ]]; then
        error "Configuration file not found: $config_file"
        return 1
    fi
    
    # Validate YAML syntax
    if command -v yq &>/dev/null; then
        if ! yq eval '.' "$config_file" &>/dev/null; then
            error "Invalid YAML syntax in configuration file"
            validation_passed=false
        else
            success "Configuration file has valid YAML syntax"
        fi
    else
        warn "yq not available, skipping YAML syntax validation"
    fi
    
    # Detect current architecture and compare
    local detection_result
    detection_result=$(detect_architecture)
    
    if [[ "$?" -eq 0 ]]; then
        local detected_mode=$(echo "$detection_result" | jq -r '.deployment_mode' 2>/dev/null || echo "unknown")
        local configured_mode
        
        if command -v yq &>/dev/null; then
            configured_mode=$(yq eval '.deployment_mode' "$config_file" 2>/dev/null || echo "unknown")
        else
            configured_mode=$(grep "deployment_mode:" "$config_file" | awk '{print $2}' | tr -d '"' || echo "unknown")
        fi
        
        if [[ "$detected_mode" == "$configured_mode" ]]; then
            success "Configuration matches detected architecture: $detected_mode"
        else
            warn "Configuration mismatch: detected=$detected_mode, configured=$configured_mode"
            validation_passed=false
        fi
    fi
    
    if [[ "$validation_passed" == "true" ]]; then
        success "Configuration validation passed"
        return 0
    else
        error "Configuration validation failed"
        return 1
    fi
}

# Switch deployment mode
switch_deployment_mode() {
    local target_mode="$DEPLOYMENT_MODE"
    
    if [[ -z "$target_mode" ]]; then
        error "Target deployment mode not specified"
        return 1
    fi
    
    log "Switching to deployment mode: $target_mode"
    
    if [[ "$FORCE" != "true" ]]; then
        warn "Switching deployment mode can be disruptive. Use --force to proceed."
        return 1
    fi
    
    # Backup current configuration
    if [[ "$DRY_RUN" != "true" ]]; then
        backup_configuration
    fi
    
    # Apply new configuration
    DEPLOYMENT_MODE="$target_mode"
    configure_system
}

# Backup configuration
backup_configuration() {
    log "Backing up current configuration..."
    
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_subdir="$BACKUP_DIR/backup-$timestamp"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY RUN: Would backup configuration to: $backup_subdir"
        return 0
    fi
    
    mkdir -p "$backup_subdir"
    
    # Backup configuration files
    if [[ -d "$CONFIG_DIR" ]]; then
        cp -r "$CONFIG_DIR"/* "$backup_subdir/" 2>/dev/null || true
    fi
    
    # Backup systemd services
    local systemd_dir="/etc/systemd/system"
    find "$systemd_dir" -name "jenkins-*" -type f -exec cp {} "$backup_subdir/" \; 2>/dev/null || true
    
    success "Configuration backed up to: $backup_subdir"
}

# Restore configuration
restore_configuration() {
    log "Restoring configuration from backup..."
    
    # List available backups
    if [[ ! -d "$BACKUP_DIR" ]]; then
        error "Backup directory not found: $BACKUP_DIR"
        return 1
    fi
    
    local backups
    backups=$(find "$BACKUP_DIR" -maxdepth 1 -type d -name "backup-*" | sort -r)
    
    if [[ -z "$backups" ]]; then
        error "No backups found in: $BACKUP_DIR"
        return 1
    fi
    
    echo "Available backups:"
    echo "$backups" | nl
    
    if [[ "$FORCE" != "true" ]]; then
        warn "Restore operation will overwrite current configuration. Use --force to proceed."
        return 1
    fi
    
    # Use latest backup
    local latest_backup=$(echo "$backups" | head -1)
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY RUN: Would restore from: $latest_backup"
        return 0
    fi
    
    # Restore files
    cp -r "$latest_backup"/* "$CONFIG_DIR/" 2>/dev/null || true
    
    success "Configuration restored from: $latest_backup"
}

# Main execution
main() {
    parse_args "$@"
    
    # Ensure required directories exist
    ensure_directories
    
    case "$ACTION" in
        "detect")
            detect_architecture
            ;;
        "configure")
            configure_system
            ;;
        "switch")
            switch_deployment_mode
            ;;
        "validate")
            validate_configuration
            ;;
        "backup")
            backup_configuration
            ;;
        "restore")
            restore_configuration
            ;;
        *)
            error "Unknown action: $ACTION"
            usage
            exit 1
            ;;
    esac
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi